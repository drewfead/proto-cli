// Code generated by protoc-gen-cli. DO NOT EDIT.

package simple

import (
	"context"
	"fmt"
	protocli "github.com/drewfead/proto-cli"
	v3 "github.com/urfave/cli/v3"
	grpc "google.golang.org/grpc"
	insecure "google.golang.org/grpc/credentials/insecure"
	"io"
	"os"
)

// getOutputWriter opens the specified output file or returns stdout
func getOutputWriter(path string) (io.Writer, error) {
	if path == "-" || path == "" {
		return os.Stdout, nil
	}
	return os.Create(path)
}

// UserServiceServiceCommand creates a service CLI for UserService with options
// The implOrFactory parameter can be either a direct service implementation or a factory function
func UserServiceServiceCommand(ctx context.Context, implOrFactory interface{}, opts ...protocli.ServiceOption) *protocli.ServiceCLI {
	options := protocli.ApplyServiceOptions(opts...)

	// Determine default format (first registered format, or empty if none)
	var defaultFormat string
	if len(options.OutputFormats()) > 0 {
		defaultFormat = options.OutputFormats()[0].Name()
	}

	var commands []*v3.Command

	// Build flags for getuser
	flags_getuser := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}}

	flags_getuser = append(flags_getuser, &v3.IntFlag{
		Name:  "id",
		Usage: "Id",
	})

	// Add config field flags for single-command mode
	flags_getuser = append(flags_getuser, &v3.StringFlag{
		Name:  "db-url",
		Usage: "PostgreSQL connection URL",
	})
	flags_getuser = append(flags_getuser, &v3.IntFlag{
		Name:  "max-conns",
		Usage: "Maximum database connections",
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_getuser = append(flags_getuser, flagConfigured.Flags()...)
		}
	}

	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if options.BeforeCommand() != nil {
				if err := options.BeforeCommand()(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			defer func() {
				if options.AfterCommand() != nil {
					if err := options.AfterCommand()(cmdCtx, cmd); err != nil {
						fmt.Fprintf(os.Stderr, "after hook failed: %v\n", err)
					}
				}
			}()

			req := &GetUserRequest{}

			req.Id = int64(cmd.Int("id"))

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *UserResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewUserServiceClient(conn)
				resp, err = client.GetUser(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Load config and create service implementation
				// Get config paths and env prefix from root command
				rootCmd := cmd.Root()
				configPaths := rootCmd.StringSlice("config")
				envPrefix := rootCmd.String("env-prefix")

				// Create config loader (single-command mode = uses files + env + flags)
				loader := protocli.NewConfigLoader(protocli.SingleCommandMode, protocli.FileConfig(configPaths...), protocli.EnvPrefix(envPrefix))

				// Create config instance and load configuration
				config := &UserServiceConfig{}
				if err := loader.LoadServiceConfig(cmd, "userservice", config); err != nil {
					return fmt.Errorf("failed to load config: %w", err)
				}

				// Call factory to create service implementation
				svcImpl, err := protocli.CallFactory(implOrFactory, config)
				if err != nil {
					return fmt.Errorf("failed to create service: %w", err)
				}

				// Call the RPC method
				resp, err = svcImpl.(UserServiceServer).GetUser(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getOutputWriter(cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Flags: flags_getuser,
		Name:  "getuser",
		Usage: "Call GetUser RPC",
	})

	// Build flags for createuser
	flags_createuser := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}}

	flags_createuser = append(flags_createuser, &v3.StringFlag{
		Name:  "name",
		Usage: "Name",
	})
	flags_createuser = append(flags_createuser, &v3.StringFlag{
		Name:  "email",
		Usage: "Email",
	})

	// Add config field flags for single-command mode
	flags_createuser = append(flags_createuser, &v3.StringFlag{
		Name:  "db-url",
		Usage: "PostgreSQL connection URL",
	})
	flags_createuser = append(flags_createuser, &v3.IntFlag{
		Name:  "max-conns",
		Usage: "Maximum database connections",
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_createuser = append(flags_createuser, flagConfigured.Flags()...)
		}
	}

	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if options.BeforeCommand() != nil {
				if err := options.BeforeCommand()(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			defer func() {
				if options.AfterCommand() != nil {
					if err := options.AfterCommand()(cmdCtx, cmd); err != nil {
						fmt.Fprintf(os.Stderr, "after hook failed: %v\n", err)
					}
				}
			}()

			req := &CreateUserRequest{}

			req.Name = cmd.String("name")
			req.Email = cmd.String("email")

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *UserResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewUserServiceClient(conn)
				resp, err = client.CreateUser(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Load config and create service implementation
				// Get config paths and env prefix from root command
				rootCmd := cmd.Root()
				configPaths := rootCmd.StringSlice("config")
				envPrefix := rootCmd.String("env-prefix")

				// Create config loader (single-command mode = uses files + env + flags)
				loader := protocli.NewConfigLoader(protocli.SingleCommandMode, protocli.FileConfig(configPaths...), protocli.EnvPrefix(envPrefix))

				// Create config instance and load configuration
				config := &UserServiceConfig{}
				if err := loader.LoadServiceConfig(cmd, "userservice", config); err != nil {
					return fmt.Errorf("failed to load config: %w", err)
				}

				// Call factory to create service implementation
				svcImpl, err := protocli.CallFactory(implOrFactory, config)
				if err != nil {
					return fmt.Errorf("failed to create service: %w", err)
				}

				// Call the RPC method
				resp, err = svcImpl.(UserServiceServer).CreateUser(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getOutputWriter(cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Flags: flags_createuser,
		Name:  "createuser",
		Usage: "Call CreateUser RPC",
	})

	return &protocli.ServiceCLI{
		Command: &v3.Command{
			Commands: commands,
			Name:     "userservice",
			Usage:    "CLI for UserService",
		},
		ConfigMessageType: "UserServiceConfig",
		ConfigPrototype:   &UserServiceConfig{},
		FactoryOrImpl:     implOrFactory,
		RegisterFunc: func(s *grpc.Server, impl interface{}) {
			RegisterUserServiceServer(s, impl.(UserServiceServer))
		},
		ServiceName: "userservice",
	}
}
