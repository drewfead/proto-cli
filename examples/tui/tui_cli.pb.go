// Code generated by protoc-gen-cli. DO NOT EDIT.

package tui

import (
	"context"
	"fmt"
	protocli "github.com/drewfead/proto-cli"
	v3 "github.com/urfave/cli/v3"
	grpc "google.golang.org/grpc"
	insecure "google.golang.org/grpc/credentials/insecure"
	metadata "google.golang.org/grpc/metadata"
	proto "google.golang.org/protobuf/proto"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	"io"
	"log/slog"
	"os"
	"strconv"
	"strings"
	"time"
)

// getFarewellServiceOutputWriter opens the specified output file or returns cmd.Writer (if set) or stdout
func getFarewellServiceOutputWriter(cmd *v3.Command, path string) (io.Writer, error) {
	if path == "-" || path == "" {
		// Use cmd.Writer if set, otherwise try root command's Writer, otherwise stdout
		if cmd.Writer != nil {
			return cmd.Writer, nil
		}
		if cmd.Root().Writer != nil {
			return cmd.Root().Writer, nil
		}
		return os.Stdout, nil
	}
	return os.Create(path)
}

// localServerStream_FarewellService_CountdownFarewell is a helper type for local server streaming calls to CountdownFarewell
type localServerStream_FarewellService_CountdownFarewell struct {
	ctx       context.Context
	responses chan *CountdownFarewellResponse
	errors    chan error
}

func (s *localServerStream_FarewellService_CountdownFarewell) Send(resp *CountdownFarewellResponse) error {
	select {
	case s.responses <- resp:
		return nil
	case <-s.ctx.Done():
		return s.ctx.Err()
	}
}

func (s *localServerStream_FarewellService_CountdownFarewell) Context() context.Context {
	return s.ctx
}

func (s *localServerStream_FarewellService_CountdownFarewell) SetHeader(metadata.MD) error {
	return nil
}

func (s *localServerStream_FarewellService_CountdownFarewell) SendHeader(metadata.MD) error {
	return nil
}

func (s *localServerStream_FarewellService_CountdownFarewell) SetTrailer(metadata.MD) {}

func (s *localServerStream_FarewellService_CountdownFarewell) SendMsg(m any) error {
	msg, ok := m.(*CountdownFarewellResponse)
	if !ok {
		return fmt.Errorf("invalid message type: expected *%s, got %T", "CountdownFarewellResponse", m)
	}
	return s.Send(msg)
}

func (s *localServerStream_FarewellService_CountdownFarewell) RecvMsg(m any) error {
	return fmt.Errorf("RecvMsg not supported on server streaming")
}

// FarewellServiceCommand creates a CLI for FarewellService with options
// The implOrFactory parameter can be either a direct service implementation or a factory function
func FarewellServiceCommand(ctx context.Context, implOrFactory interface{}, opts ...protocli.ServiceOption) *protocli.ServiceCLI {
	options := protocli.ApplyServiceOptions(opts...)

	// Determine default format (first registered format, or empty if none)
	var defaultFormat string
	if len(options.OutputFormats()) > 0 {
		defaultFormat = options.OutputFormats()[0].Name()
	}

	var commands []*v3.Command

	// Build flags for farewell
	flags_farewell := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_farewell = append(flags_farewell, &v3.StringFlag{
		Name:     "name",
		Required: true,
		Usage:    "Name to bid farewell",
	})
	flags_farewell = append(flags_farewell, &v3.BoolFlag{
		Name:  "formal",
		Usage: "Use a formal farewell",
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_farewell = append(flags_farewell, flagConfigured.Flags()...)
		}
	}

	flags_farewell = append(flags_farewell, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *FarewellRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &FarewellRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("name") {
					req.Name = cmd.String("name")
				}
				if cmd.IsSet("formal") {
					req.Formal = cmd.Bool("formal")
				}
			} else {
				// Check for custom flag deserializer for tui_example.FarewellRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.FarewellRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					// Create FlagContainer (deserializer can access multiple flags via Command())
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					// Handle nil return from deserializer
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*FarewellRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "FarewellRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &FarewellRequest{}
					req.Name = cmd.String("name")
					req.Formal = cmd.Bool("formal")
				}
			}

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *FarewellResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewFarewellServiceClient(conn)
				resp, err = client.Farewell(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(FarewellServiceServer)
				resp, err = svcImpl.Farewell(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getFarewellServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					// Write final newline to keep terminal clean
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if cmd.IsSet("name") {
					prefill["name"] = cmd.String("name")
				}
				if cmd.IsSet("formal") {
					prefill["formal"] = strconv.FormatBool(cmd.Bool("formal"))
				}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("farewell", "farewell"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_farewell,
		Name:  "farewell",
		Usage: "Say goodbye to someone",
	})

	// Build flags for farewell-many
	flags_farewell_many := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_farewell_many = append(flags_farewell_many, &v3.StringSliceFlag{
		Name:  "names",
		Usage: "Names to bid farewell (comma-separated in TUI)",
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_farewell_many = append(flags_farewell_many, flagConfigured.Flags()...)
		}
	}

	flags_farewell_many = append(flags_farewell_many, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *FarewellManyRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &FarewellManyRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("names") {
					req.Names = cmd.StringSlice("names")
				}
			} else {
				// Check for custom flag deserializer for tui_example.FarewellManyRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.FarewellManyRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					// Create FlagContainer (deserializer can access multiple flags via Command())
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					// Handle nil return from deserializer
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*FarewellManyRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "FarewellManyRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &FarewellManyRequest{}
					req.Names = cmd.StringSlice("names")
				}
			}

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *FarewellManyResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewFarewellServiceClient(conn)
				resp, err = client.FarewellMany(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(FarewellServiceServer)
				resp, err = svcImpl.FarewellMany(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getFarewellServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					// Write final newline to keep terminal clean
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("farewell", "farewell-many"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_farewell_many,
		Name:  "farewell-many",
		Usage: "Say goodbye to multiple people",
	})

	// Build flags for scheduled-farewell
	flags_scheduled_farewell := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_scheduled_farewell = append(flags_scheduled_farewell, &v3.StringFlag{
		Name:     "name",
		Required: true,
		Usage:    "Name to bid farewell",
	})
	flags_scheduled_farewell = append(flags_scheduled_farewell, &v3.StringFlag{
		Name:  "send-at",
		Usage: "When to send the farewell (RFC3339)",
	})
	flags_scheduled_farewell = append(flags_scheduled_farewell, &v3.StringFlag{
		Name:  "address",
		Usage: "Address (tui_example.DeliveryAddress)",
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_scheduled_farewell = append(flags_scheduled_farewell, flagConfigured.Flags()...)
		}
	}

	flags_scheduled_farewell = append(flags_scheduled_farewell, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *ScheduledFarewellRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &ScheduledFarewellRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("name") {
					req.Name = cmd.String("name")
				}
				if cmd.IsSet("send-at") {
					if fieldDeserializer, hasFieldDeserializer := options.FlagDeserializer("google.protobuf.Timestamp"); hasFieldDeserializer {
						fieldFlags := protocli.NewFlagContainer(cmd, "send-at")
						fieldMsg, fieldErr := fieldDeserializer(cmdCtx, fieldFlags)
						if fieldErr != nil {
							return fmt.Errorf("failed to deserialize field SendAt: %w", fieldErr)
						}
						if fieldMsg != nil {
							typedField, fieldOk := fieldMsg.(*timestamppb.Timestamp)
							if !fieldOk {
								return fmt.Errorf("custom deserializer for google.protobuf.Timestamp returned wrong type: expected *Timestamp, got %T", fieldMsg)
							}
							req.SendAt = typedField
						}
					} else {
						return fmt.Errorf("flag --send-at requires a custom deserializer for google.protobuf.Timestamp (register with protocli.WithFlagDeserializer)")
					}
				}
				if cmd.IsSet("address") {
					if fieldDeserializer, hasFieldDeserializer := options.FlagDeserializer("tui_example.DeliveryAddress"); hasFieldDeserializer {
						fieldFlags := protocli.NewFlagContainer(cmd, "address")
						fieldMsg, fieldErr := fieldDeserializer(cmdCtx, fieldFlags)
						if fieldErr != nil {
							return fmt.Errorf("failed to deserialize field Address: %w", fieldErr)
						}
						if fieldMsg != nil {
							typedField, fieldOk := fieldMsg.(*DeliveryAddress)
							if !fieldOk {
								return fmt.Errorf("custom deserializer for tui_example.DeliveryAddress returned wrong type: expected *DeliveryAddress, got %T", fieldMsg)
							}
							req.Address = typedField
						}
					} else {
						return fmt.Errorf("flag --address requires a custom deserializer for tui_example.DeliveryAddress (register with protocli.WithFlagDeserializer)")
					}
				}
			} else {
				// Check for custom flag deserializer for tui_example.ScheduledFarewellRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.ScheduledFarewellRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					// Create FlagContainer (deserializer can access multiple flags via Command())
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					// Handle nil return from deserializer
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*ScheduledFarewellRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "ScheduledFarewellRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &ScheduledFarewellRequest{}
					req.Name = cmd.String("name")
					// Field SendAt: check for custom deserializer for google.protobuf.Timestamp
					if fieldDeserializer, hasFieldDeserializer := options.FlagDeserializer("google.protobuf.Timestamp"); hasFieldDeserializer {
						// Use custom deserializer for nested message
						// Create FlagContainer for field flag: send-at
						fieldFlags := protocli.NewFlagContainer(cmd, "send-at")
						fieldMsg, fieldErr := fieldDeserializer(cmdCtx, fieldFlags)
						if fieldErr != nil {
							return fmt.Errorf("failed to deserialize field SendAt: %w", fieldErr)
						}
						// Handle nil return from deserializer (means skip/use default)
						if fieldMsg != nil {
							typedField, fieldOk := fieldMsg.(*timestamppb.Timestamp)
							if !fieldOk {
								return fmt.Errorf("custom deserializer for google.protobuf.Timestamp returned wrong type: expected *Timestamp, got %T", fieldMsg)
							}
							req.SendAt = typedField
						}
					} else {
						// No custom deserializer - check if user provided a value
						if cmd.IsSet("send-at") {
							return fmt.Errorf("flag --send-at requires a custom deserializer for google.protobuf.Timestamp (register with protocli.WithFlagDeserializer)")
						}
						// No value provided - leave field as nil
					}
					// Field Address: check for custom deserializer for tui_example.DeliveryAddress
					if fieldDeserializer, hasFieldDeserializer := options.FlagDeserializer("tui_example.DeliveryAddress"); hasFieldDeserializer {
						// Use custom deserializer for nested message
						// Create FlagContainer for field flag: address
						fieldFlags := protocli.NewFlagContainer(cmd, "address")
						fieldMsg, fieldErr := fieldDeserializer(cmdCtx, fieldFlags)
						if fieldErr != nil {
							return fmt.Errorf("failed to deserialize field Address: %w", fieldErr)
						}
						// Handle nil return from deserializer (means skip/use default)
						if fieldMsg != nil {
							typedField, fieldOk := fieldMsg.(*DeliveryAddress)
							if !fieldOk {
								return fmt.Errorf("custom deserializer for tui_example.DeliveryAddress returned wrong type: expected *DeliveryAddress, got %T", fieldMsg)
							}
							req.Address = typedField
						}
					} else {
						// No custom deserializer - check if user provided a value
						if cmd.IsSet("address") {
							return fmt.Errorf("flag --address requires a custom deserializer for tui_example.DeliveryAddress (register with protocli.WithFlagDeserializer)")
						}
						// No value provided - leave field as nil
					}
				}
			}

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *ScheduledFarewellResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewFarewellServiceClient(conn)
				resp, err = client.ScheduledFarewell(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(FarewellServiceServer)
				resp, err = svcImpl.ScheduledFarewell(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getFarewellServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					// Write final newline to keep terminal clean
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if cmd.IsSet("name") {
					prefill["name"] = cmd.String("name")
				}
				if cmd.IsSet("send-at") {
					prefill["send-at"] = cmd.String("send-at")
				}
				if cmd.IsSet("address") {
					prefill["address"] = cmd.String("address")
				}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("farewell", "scheduled-farewell"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_scheduled_farewell,
		Name:  "scheduled-farewell",
		Usage: "Schedule a goodbye for a specific time and place",
	})

	// Build flags for leave-note
	flags_leave_note := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_leave_note = append(flags_leave_note, &v3.StringFlag{
		Name:     "name",
		Required: true,
		Usage:    "Name to address the note to",
	})
	flags_leave_note = append(flags_leave_note, &v3.StringFlag{
		Name:  "metadata",
		Usage: "Free-form JSON metadata",
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_leave_note = append(flags_leave_note, flagConfigured.Flags()...)
		}
	}

	flags_leave_note = append(flags_leave_note, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *NoteRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &NoteRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("name") {
					req.Name = cmd.String("name")
				}
				if cmd.IsSet("metadata") {
					req.Metadata = cmd.String("metadata")
				}
			} else {
				// Check for custom flag deserializer for tui_example.NoteRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.NoteRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					// Create FlagContainer (deserializer can access multiple flags via Command())
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					// Handle nil return from deserializer
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*NoteRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "NoteRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &NoteRequest{}
					req.Name = cmd.String("name")
					req.Metadata = cmd.String("metadata")
				}
			}

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *NoteResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewFarewellServiceClient(conn)
				resp, err = client.LeaveNote(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(FarewellServiceServer)
				resp, err = svcImpl.LeaveNote(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getFarewellServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					// Write final newline to keep terminal clean
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if cmd.IsSet("name") {
					prefill["name"] = cmd.String("name")
				}
				if cmd.IsSet("metadata") {
					prefill["metadata"] = cmd.String("metadata")
				}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("farewell", "leave-note"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_leave_note,
		Name:  "leave-note",
		Usage: "Attach a JSON note to a farewell",
	})

	// Build flags for countdown-farewell
	flags_countdown_farewell := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "delimiter",
		Usage: "Delimiter between streamed messages",
		Value: "\n",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_countdown_farewell = append(flags_countdown_farewell, &v3.StringFlag{
		Name:     "name",
		Required: true,
		Usage:    "Name to bid farewell",
	})
	flags_countdown_farewell = append(flags_countdown_farewell, &v3.Int32Flag{
		Name:  "from",
		Usage: "Countdown starting number",
		Value: int32(5),
	})
	flags_countdown_farewell = append(flags_countdown_farewell, &v3.Int32Flag{
		Name:  "delay-ms",
		Usage: "Milliseconds between countdown ticks",
		Value: int32(500),
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_countdown_farewell = append(flags_countdown_farewell, flagConfigured.Flags()...)
		}
	}

	flags_countdown_farewell = append(flags_countdown_farewell, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return fmt.Errorf("unsupported argument: %s", cmd.Args().Get(0))
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *CountdownFarewellRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &CountdownFarewellRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("name") {
					req.Name = cmd.String("name")
				}
				if cmd.IsSet("from") {
					req.From = cmd.Int32("from")
				}
				if cmd.IsSet("delay-ms") {
					req.DelayMs = cmd.Int32("delay-ms")
				}
			} else {
				// Check for custom flag deserializer for tui_example.CountdownFarewellRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.CountdownFarewellRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*CountdownFarewellRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "CountdownFarewellRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &CountdownFarewellRequest{}
					req.Name = cmd.String("name")
					req.From = cmd.Int32("from")
					req.DelayMs = cmd.Int32("delay-ms")
				}
			}

			// Open output writer
			outputWriter, err := getFarewellServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find the appropriate output format
			formatName := cmd.String("format")
			var outputFmt protocli.OutputFormat
			for _, f := range options.OutputFormats() {
				if f.Name() == formatName {
					outputFmt = f
					break
				}
			}
			if outputFmt == nil {
				var availableFormats []string
				for _, f := range options.OutputFormats() {
					availableFormats = append(availableFormats, f.Name())
				}
				return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
			}

			// Get delimiter for separating streamed messages
			delimiter := cmd.String("delimiter")

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")

			if remoteAddr != "" {
				// Remote gRPC streaming call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewFarewellServiceClient(conn)
				stream, err := client.CountdownFarewell(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("failed to start stream: %w", err)
				}

				// Receive and format each message in the stream
				var messageCount int
				for {
					msg, recvErr := stream.Recv()
					if recvErr == io.EOF {
						break
					}
					if recvErr != nil {
						return fmt.Errorf("stream receive error: %w", recvErr)
					}

					// Format and write the message
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, msg); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}

					// Write delimiter
					if _, err := outputWriter.Write([]byte(delimiter)); err != nil {
						return fmt.Errorf("failed to write delimiter: %w", err)
					}
					messageCount++
				}

				// Write final newline to keep terminal clean (only if delimiter doesn't already end with newline)
				if messageCount > 0 && !strings.HasSuffix(delimiter, "\n") {
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(FarewellServiceServer)

				// Create local stream wrapper for direct call
				localStream := &localServerStream_FarewellService_CountdownFarewell{
					ctx:       cmdCtx,
					errors:    make(chan error),
					responses: make(chan *CountdownFarewellResponse),
				}

				// Call streaming method in goroutine
				go func() {
					var methodErr error
					methodErr = svcImpl.CountdownFarewell(req, localStream)
					close(localStream.responses)
					if methodErr != nil {
						localStream.errors <- methodErr
					}
					close(localStream.errors)
				}()

				// Receive and format each message in the stream
				var messageCount int
				for {
					select {
					case msg, ok := <-localStream.responses:
						if !ok {
							// Stream closed, check for errors
							if streamErr := <-localStream.errors; streamErr != nil {
								return fmt.Errorf("stream error: %w", streamErr)
							}
							// Write final newline to keep terminal clean (only if delimiter doesn't already end with newline)
							if messageCount > 0 && !strings.HasSuffix(delimiter, "\n") {
								if _, err := outputWriter.Write([]byte("\n")); err != nil {
									return fmt.Errorf("failed to write final newline: %w", err)
								}
							}
							return nil
						}

						// Format and write the message
						if err := outputFmt.Format(cmdCtx, cmd, outputWriter, msg); err != nil {
							return fmt.Errorf("format failed: %w", err)
						}

						// Write delimiter
						if _, err := outputWriter.Write([]byte(delimiter)); err != nil {
							return fmt.Errorf("failed to write delimiter: %w", err)
						}
						messageCount++
					case <-cmdCtx.Done():
						return cmdCtx.Err()
					}
				}
			}

			return nil
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if cmd.IsSet("name") {
					prefill["name"] = cmd.String("name")
				}
				if cmd.IsSet("from") {
					prefill["from"] = strconv.FormatInt(int64(cmd.Int32("from")), 10)
				}
				if cmd.IsSet("delay-ms") {
					prefill["delay-ms"] = strconv.FormatInt(int64(cmd.Int32("delay-ms")), 10)
				}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("farewell", "countdown-farewell"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_countdown_farewell,
		Name:  "countdown-farewell",
		Usage: "Count down to a dramatic goodbye",
	})

	return &protocli.ServiceCLI{
		Command: &v3.Command{
			Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
				if cmd.Args().Len() > 0 {
					return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
				}
				if cmd.Bool("interactive") {
					if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtService("farewell")); err != nil {
						return ctx, err
					}
					return ctx, v3.Exit("", 0)
				}
				return ctx, nil
			},
			Commands: commands,
			Flags: []v3.Flag{&v3.BoolFlag{
				Name:  "interactive",
				Usage: "Open the interactive TUI at this service",
			}},
			Name:  "farewell",
			Usage: "FarewellService demonstrates a second TUI-enabled service.",
		},
		ConfigMessageType: "",
		FactoryOrImpl:     implOrFactory,
		RegisterFunc: func(s *grpc.Server, impl interface{}) {
			RegisterFarewellServiceServer(s, impl.(FarewellServiceServer))
		},
		ServiceName: "farewell",
		TUIDescriptor: &protocli.TUIServiceDescriptor{
			Description: "Farewell commands",
			DisplayName: "Farewell",
			Methods: []*protocli.TUIMethodDescriptor{&protocli.TUIMethodDescriptor{
				Description: "Say goodbye to someone",
				DisplayName: "Bid Farewell",
				Hidden:      false,
				InputFields: []protocli.TUIFieldDescriptor{protocli.TUIFieldDescriptor{
					DefaultValue: "",
					Description:  "",
					Hidden:       false,
					Kind:         protocli.TUIFieldKindString,
					Label:        "Name",
					Name:         "name",
					Required:     true,
					Setter: func(msg proto.Message, s string) error {
						req := msg.(*FarewellRequest)
						req.Name = s
						return nil
					},
					Usage: "Name to bid farewell",
				}, protocli.TUIFieldDescriptor{
					DefaultValue: "",
					Description:  "",
					Hidden:       false,
					Kind:         protocli.TUIFieldKindBool,
					Label:        "Formal",
					Name:         "formal",
					Required:     false,
					Setter: func(msg proto.Message, s string) error {
						req := msg.(*FarewellRequest)
						v, err := strconv.ParseBool(s)
						if err != nil {
							return fmt.Errorf("invalid bool for formal: %w", err)
						}
						req.Formal = v
						return nil
					},
					Usage: "Use a formal farewell",
				}},
				Invoke: func(ctx context.Context, cmd *v3.Command, req proto.Message) (proto.Message, error) {
					typedReq := req.(*FarewellRequest)
					svcImpl := implOrFactory.(FarewellServiceServer)
					resp, err := svcImpl.Farewell(ctx, typedReq)
					if err != nil {
						return nil, fmt.Errorf("method failed: %w", err)
					}
					return proto.Message(resp), nil
				},
				IsStreaming: false,
				Name:        "farewell",
				NewRequest: func() proto.Message {
					return &FarewellRequest{}
				},
				ResponseDescriptor: protocli.TUIResponseDescriptor{
					MessageFullName: "tui_example.FarewellResponse",
					MethodName:      "farewell",
				},
			}, &protocli.TUIMethodDescriptor{
				Description: "Say goodbye to multiple people",
				DisplayName: "Bid Farewell to Many",
				Hidden:      false,
				InputFields: []protocli.TUIFieldDescriptor{protocli.TUIFieldDescriptor{
					Appender: func(msg proto.Message, s string) error {
						req := msg.(*FarewellManyRequest)
						req.Names = append(req.Names, s)
						return nil
					},
					DefaultValue: "",
					Description:  "",
					ElementKind:  protocli.TUIFieldKindString,
					Hidden:       false,
					Kind:         protocli.TUIFieldKindRepeated,
					Label:        "Names",
					Name:         "names",
					Required:     false,
					Usage:        "Names to bid farewell (comma-separated in TUI)",
				}},
				Invoke: func(ctx context.Context, cmd *v3.Command, req proto.Message) (proto.Message, error) {
					typedReq := req.(*FarewellManyRequest)
					svcImpl := implOrFactory.(FarewellServiceServer)
					resp, err := svcImpl.FarewellMany(ctx, typedReq)
					if err != nil {
						return nil, fmt.Errorf("method failed: %w", err)
					}
					return proto.Message(resp), nil
				},
				IsStreaming: false,
				Name:        "farewell-many",
				NewRequest: func() proto.Message {
					return &FarewellManyRequest{}
				},
				ResponseDescriptor: protocli.TUIResponseDescriptor{
					MessageFullName: "tui_example.FarewellManyResponse",
					MethodName:      "farewell-many",
				},
			}, &protocli.TUIMethodDescriptor{
				Description: "Schedule a goodbye for a specific time and place",
				DisplayName: "Schedule a Farewell",
				Hidden:      false,
				InputFields: []protocli.TUIFieldDescriptor{protocli.TUIFieldDescriptor{
					DefaultValue: "",
					Description:  "",
					Hidden:       false,
					Kind:         protocli.TUIFieldKindString,
					Label:        "Name",
					Name:         "name",
					Required:     true,
					Setter: func(msg proto.Message, s string) error {
						req := msg.(*ScheduledFarewellRequest)
						req.Name = s
						return nil
					},
					Usage: "Name to bid farewell",
				}, protocli.TUIFieldDescriptor{
					DefaultValue:    "",
					Description:     "",
					Hidden:          false,
					Kind:            protocli.TUIFieldKindString,
					Label:           "Send At",
					MessageFullName: "google.protobuf.Timestamp",
					Name:            "send-at",
					Required:        false,
					Setter: func(msg proto.Message, s string) error {
						req := msg.(*ScheduledFarewellRequest)
						t, err := time.Parse(time.RFC3339, s)
						if err != nil {
							return fmt.Errorf("invalid RFC3339 timestamp for send-at: %w", err)
						}
						req.SendAt = timestamppb.New(t)
						return nil
					},
					Usage: "When to send the farewell (RFC3339)",
				}, protocli.TUIFieldDescriptor{
					DefaultValue: "",
					Description:  "",
					Fields: []protocli.TUIFieldDescriptor{protocli.TUIFieldDescriptor{
						DefaultValue: "",
						Description:  "",
						Hidden:       false,
						Kind:         protocli.TUIFieldKindString,
						Label:        "Street",
						Name:         "street",
						Required:     false,
						Setter: func(msg proto.Message, s string) error {
							req := msg.(*ScheduledFarewellRequest)
							if req.Address == nil {
								req.Address = &DeliveryAddress{}
							}
							req.Address.Street = s
							return nil
						},
						Usage: "Street address",
					}, protocli.TUIFieldDescriptor{
						DefaultValue: "",
						Description:  "",
						Hidden:       false,
						Kind:         protocli.TUIFieldKindString,
						Label:        "City",
						Name:         "city",
						Required:     false,
						Setter: func(msg proto.Message, s string) error {
							req := msg.(*ScheduledFarewellRequest)
							if req.Address == nil {
								req.Address = &DeliveryAddress{}
							}
							req.Address.City = s
							return nil
						},
						Usage: "City",
					}},
					Hidden:          false,
					Kind:            protocli.TUIFieldKindMessage,
					Label:           "Delivery Address",
					MessageFullName: "tui_example.DeliveryAddress",
					Name:            "address",
					Required:        false,
					Usage:           "address is where to deliver the farewell. Demonstrates nested message flattening in the TUI.",
				}},
				Invoke: func(ctx context.Context, cmd *v3.Command, req proto.Message) (proto.Message, error) {
					typedReq := req.(*ScheduledFarewellRequest)
					svcImpl := implOrFactory.(FarewellServiceServer)
					resp, err := svcImpl.ScheduledFarewell(ctx, typedReq)
					if err != nil {
						return nil, fmt.Errorf("method failed: %w", err)
					}
					return proto.Message(resp), nil
				},
				IsStreaming: false,
				Name:        "scheduled-farewell",
				NewRequest: func() proto.Message {
					return &ScheduledFarewellRequest{}
				},
				ResponseDescriptor: protocli.TUIResponseDescriptor{
					MessageFullName: "tui_example.ScheduledFarewellResponse",
					MethodName:      "scheduled-farewell",
				},
			}, &protocli.TUIMethodDescriptor{
				Description: "Attach a JSON note to a farewell",
				DisplayName: "LeaveNote",
				Hidden:      false,
				InputFields: []protocli.TUIFieldDescriptor{protocli.TUIFieldDescriptor{
					DefaultValue: "",
					Description:  "",
					Hidden:       false,
					Kind:         protocli.TUIFieldKindString,
					Label:        "Name",
					Name:         "name",
					Required:     true,
					Setter: func(msg proto.Message, s string) error {
						req := msg.(*NoteRequest)
						req.Name = s
						return nil
					},
					Usage: "Name to address the note to",
				}, protocli.TUIFieldDescriptor{
					DefaultValue: "",
					Description:  "",
					Hidden:       false,
					Kind:         protocli.TUIFieldKindString,
					Label:        "Metadata (JSON)",
					Name:         "metadata",
					Required:     false,
					Setter: func(msg proto.Message, s string) error {
						req := msg.(*NoteRequest)
						req.Metadata = s
						return nil
					},
					Usage: "Free-form JSON metadata",
				}},
				Invoke: func(ctx context.Context, cmd *v3.Command, req proto.Message) (proto.Message, error) {
					typedReq := req.(*NoteRequest)
					svcImpl := implOrFactory.(FarewellServiceServer)
					resp, err := svcImpl.LeaveNote(ctx, typedReq)
					if err != nil {
						return nil, fmt.Errorf("method failed: %w", err)
					}
					return proto.Message(resp), nil
				},
				IsStreaming: false,
				Name:        "leave-note",
				NewRequest: func() proto.Message {
					return &NoteRequest{}
				},
				ResponseDescriptor: protocli.TUIResponseDescriptor{
					MessageFullName: "tui_example.NoteResponse",
					MethodName:      "leave-note",
				},
			}, &protocli.TUIMethodDescriptor{
				Description: "Count down to a dramatic goodbye",
				DisplayName: "Countdown Farewell",
				Hidden:      false,
				InputFields: []protocli.TUIFieldDescriptor{protocli.TUIFieldDescriptor{
					DefaultValue: "",
					Description:  "",
					Hidden:       false,
					Kind:         protocli.TUIFieldKindString,
					Label:        "Name",
					Name:         "name",
					Required:     true,
					Setter: func(msg proto.Message, s string) error {
						req := msg.(*CountdownFarewellRequest)
						req.Name = s
						return nil
					},
					Usage: "Name to bid farewell",
				}, protocli.TUIFieldDescriptor{
					DefaultValue: "5",
					Description:  "",
					Hidden:       false,
					Kind:         protocli.TUIFieldKindInt,
					Label:        "From",
					Name:         "from",
					Required:     false,
					Setter: func(msg proto.Message, s string) error {
						req := msg.(*CountdownFarewellRequest)
						n, err := strconv.ParseInt(s, 10, 32)
						if err != nil {
							return fmt.Errorf("invalid int32 for from: %w", err)
						}
						req.From = int32(n)
						return nil
					},
					Usage: "Countdown starting number",
				}, protocli.TUIFieldDescriptor{
					DefaultValue: "500",
					Description:  "",
					Hidden:       false,
					Kind:         protocli.TUIFieldKindInt,
					Label:        "Delay Ms",
					Name:         "delay-ms",
					Required:     false,
					Setter: func(msg proto.Message, s string) error {
						req := msg.(*CountdownFarewellRequest)
						n, err := strconv.ParseInt(s, 10, 32)
						if err != nil {
							return fmt.Errorf("invalid int32 for delay-ms: %w", err)
						}
						req.DelayMs = int32(n)
						return nil
					},
					Usage: "Milliseconds between countdown ticks",
				}},
				Invoke: func(ctx context.Context, cmd *v3.Command, req proto.Message) (proto.Message, error) {
					return nil, fmt.Errorf("use InvokeStream for server-streaming method CountdownFarewell")
				},
				InvokeStream: func(ctx context.Context, cmd *v3.Command, req proto.Message, recv func(proto.Message) error) error {
					typedReq := req.(*CountdownFarewellRequest)
					typedImpl := implOrFactory.(FarewellServiceServer)
					localStream := &localServerStream_FarewellService_CountdownFarewell{
						ctx:       ctx,
						errors:    make(chan error),
						responses: make(chan *CountdownFarewellResponse),
					}
					go func() {
						var methodErr error
						methodErr = typedImpl.CountdownFarewell(typedReq, localStream)
						close(localStream.responses)
						if methodErr != nil {
							localStream.errors <- methodErr
						}
						close(localStream.errors)
					}()
					for {
						select {
						case msg, ok := <-localStream.responses:
							if !ok {
								if streamErr := <-localStream.errors; streamErr != nil {
									return fmt.Errorf("stream error: %w", streamErr)
								}
								return nil
							}
							if recvErr := recv(msg); recvErr != nil {
								return fmt.Errorf("recv callback failed: %w", recvErr)
							}
						case <-ctx.Done():
							return ctx.Err()
						}
					}
				},
				IsStreaming: true,
				Name:        "countdown-farewell",
				NewRequest: func() proto.Message {
					return &CountdownFarewellRequest{}
				},
				ResponseDescriptor: protocli.TUIResponseDescriptor{
					MessageFullName: "tui_example.CountdownFarewellResponse",
					MethodName:      "countdown-farewell",
				},
			}},
			Name: "farewell",
		},
	}
}

// FarewellServiceCommandsFlat creates a flat command structure for FarewellService (for single-service CLIs)
// This returns RPC commands directly at the root level instead of nested under a service command.
// The implOrFactory parameter can be either a direct service implementation or a factory function
// The returned slice includes all RPC commands plus a daemonize command for starting a gRPC server.
func FarewellServiceCommandsFlat(ctx context.Context, implOrFactory interface{}, opts ...protocli.ServiceOption) []*v3.Command {
	options := protocli.ApplyServiceOptions(opts...)

	// Determine default format (first registered format, or empty if none)
	var defaultFormat string
	if len(options.OutputFormats()) > 0 {
		defaultFormat = options.OutputFormats()[0].Name()
	}

	var commands []*v3.Command

	// Build flags for farewell
	flags_farewell := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_farewell = append(flags_farewell, &v3.StringFlag{
		Name:     "name",
		Required: true,
		Usage:    "Name to bid farewell",
	})
	flags_farewell = append(flags_farewell, &v3.BoolFlag{
		Name:  "formal",
		Usage: "Use a formal farewell",
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_farewell = append(flags_farewell, flagConfigured.Flags()...)
		}
	}

	flags_farewell = append(flags_farewell, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *FarewellRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &FarewellRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("name") {
					req.Name = cmd.String("name")
				}
				if cmd.IsSet("formal") {
					req.Formal = cmd.Bool("formal")
				}
			} else {
				// Check for custom flag deserializer for tui_example.FarewellRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.FarewellRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					// Create FlagContainer (deserializer can access multiple flags via Command())
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					// Handle nil return from deserializer
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*FarewellRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "FarewellRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &FarewellRequest{}
					req.Name = cmd.String("name")
					req.Formal = cmd.Bool("formal")
				}
			}

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *FarewellResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewFarewellServiceClient(conn)
				resp, err = client.Farewell(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(FarewellServiceServer)
				resp, err = svcImpl.Farewell(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getFarewellServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					// Write final newline to keep terminal clean
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if cmd.IsSet("name") {
					prefill["name"] = cmd.String("name")
				}
				if cmd.IsSet("formal") {
					prefill["formal"] = strconv.FormatBool(cmd.Bool("formal"))
				}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("farewell", "farewell"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_farewell,
		Name:  "farewell",
		Usage: "Say goodbye to someone",
	})

	// Build flags for farewell-many
	flags_farewell_many := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_farewell_many = append(flags_farewell_many, &v3.StringSliceFlag{
		Name:  "names",
		Usage: "Names to bid farewell (comma-separated in TUI)",
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_farewell_many = append(flags_farewell_many, flagConfigured.Flags()...)
		}
	}

	flags_farewell_many = append(flags_farewell_many, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *FarewellManyRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &FarewellManyRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("names") {
					req.Names = cmd.StringSlice("names")
				}
			} else {
				// Check for custom flag deserializer for tui_example.FarewellManyRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.FarewellManyRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					// Create FlagContainer (deserializer can access multiple flags via Command())
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					// Handle nil return from deserializer
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*FarewellManyRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "FarewellManyRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &FarewellManyRequest{}
					req.Names = cmd.StringSlice("names")
				}
			}

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *FarewellManyResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewFarewellServiceClient(conn)
				resp, err = client.FarewellMany(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(FarewellServiceServer)
				resp, err = svcImpl.FarewellMany(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getFarewellServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					// Write final newline to keep terminal clean
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("farewell", "farewell-many"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_farewell_many,
		Name:  "farewell-many",
		Usage: "Say goodbye to multiple people",
	})

	// Build flags for scheduled-farewell
	flags_scheduled_farewell := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_scheduled_farewell = append(flags_scheduled_farewell, &v3.StringFlag{
		Name:     "name",
		Required: true,
		Usage:    "Name to bid farewell",
	})
	flags_scheduled_farewell = append(flags_scheduled_farewell, &v3.StringFlag{
		Name:  "send-at",
		Usage: "When to send the farewell (RFC3339)",
	})
	flags_scheduled_farewell = append(flags_scheduled_farewell, &v3.StringFlag{
		Name:  "address",
		Usage: "Address (tui_example.DeliveryAddress)",
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_scheduled_farewell = append(flags_scheduled_farewell, flagConfigured.Flags()...)
		}
	}

	flags_scheduled_farewell = append(flags_scheduled_farewell, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *ScheduledFarewellRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &ScheduledFarewellRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("name") {
					req.Name = cmd.String("name")
				}
				if cmd.IsSet("send-at") {
					if fieldDeserializer, hasFieldDeserializer := options.FlagDeserializer("google.protobuf.Timestamp"); hasFieldDeserializer {
						fieldFlags := protocli.NewFlagContainer(cmd, "send-at")
						fieldMsg, fieldErr := fieldDeserializer(cmdCtx, fieldFlags)
						if fieldErr != nil {
							return fmt.Errorf("failed to deserialize field SendAt: %w", fieldErr)
						}
						if fieldMsg != nil {
							typedField, fieldOk := fieldMsg.(*timestamppb.Timestamp)
							if !fieldOk {
								return fmt.Errorf("custom deserializer for google.protobuf.Timestamp returned wrong type: expected *Timestamp, got %T", fieldMsg)
							}
							req.SendAt = typedField
						}
					} else {
						return fmt.Errorf("flag --send-at requires a custom deserializer for google.protobuf.Timestamp (register with protocli.WithFlagDeserializer)")
					}
				}
				if cmd.IsSet("address") {
					if fieldDeserializer, hasFieldDeserializer := options.FlagDeserializer("tui_example.DeliveryAddress"); hasFieldDeserializer {
						fieldFlags := protocli.NewFlagContainer(cmd, "address")
						fieldMsg, fieldErr := fieldDeserializer(cmdCtx, fieldFlags)
						if fieldErr != nil {
							return fmt.Errorf("failed to deserialize field Address: %w", fieldErr)
						}
						if fieldMsg != nil {
							typedField, fieldOk := fieldMsg.(*DeliveryAddress)
							if !fieldOk {
								return fmt.Errorf("custom deserializer for tui_example.DeliveryAddress returned wrong type: expected *DeliveryAddress, got %T", fieldMsg)
							}
							req.Address = typedField
						}
					} else {
						return fmt.Errorf("flag --address requires a custom deserializer for tui_example.DeliveryAddress (register with protocli.WithFlagDeserializer)")
					}
				}
			} else {
				// Check for custom flag deserializer for tui_example.ScheduledFarewellRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.ScheduledFarewellRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					// Create FlagContainer (deserializer can access multiple flags via Command())
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					// Handle nil return from deserializer
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*ScheduledFarewellRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "ScheduledFarewellRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &ScheduledFarewellRequest{}
					req.Name = cmd.String("name")
					// Field SendAt: check for custom deserializer for google.protobuf.Timestamp
					if fieldDeserializer, hasFieldDeserializer := options.FlagDeserializer("google.protobuf.Timestamp"); hasFieldDeserializer {
						// Use custom deserializer for nested message
						// Create FlagContainer for field flag: send-at
						fieldFlags := protocli.NewFlagContainer(cmd, "send-at")
						fieldMsg, fieldErr := fieldDeserializer(cmdCtx, fieldFlags)
						if fieldErr != nil {
							return fmt.Errorf("failed to deserialize field SendAt: %w", fieldErr)
						}
						// Handle nil return from deserializer (means skip/use default)
						if fieldMsg != nil {
							typedField, fieldOk := fieldMsg.(*timestamppb.Timestamp)
							if !fieldOk {
								return fmt.Errorf("custom deserializer for google.protobuf.Timestamp returned wrong type: expected *Timestamp, got %T", fieldMsg)
							}
							req.SendAt = typedField
						}
					} else {
						// No custom deserializer - check if user provided a value
						if cmd.IsSet("send-at") {
							return fmt.Errorf("flag --send-at requires a custom deserializer for google.protobuf.Timestamp (register with protocli.WithFlagDeserializer)")
						}
						// No value provided - leave field as nil
					}
					// Field Address: check for custom deserializer for tui_example.DeliveryAddress
					if fieldDeserializer, hasFieldDeserializer := options.FlagDeserializer("tui_example.DeliveryAddress"); hasFieldDeserializer {
						// Use custom deserializer for nested message
						// Create FlagContainer for field flag: address
						fieldFlags := protocli.NewFlagContainer(cmd, "address")
						fieldMsg, fieldErr := fieldDeserializer(cmdCtx, fieldFlags)
						if fieldErr != nil {
							return fmt.Errorf("failed to deserialize field Address: %w", fieldErr)
						}
						// Handle nil return from deserializer (means skip/use default)
						if fieldMsg != nil {
							typedField, fieldOk := fieldMsg.(*DeliveryAddress)
							if !fieldOk {
								return fmt.Errorf("custom deserializer for tui_example.DeliveryAddress returned wrong type: expected *DeliveryAddress, got %T", fieldMsg)
							}
							req.Address = typedField
						}
					} else {
						// No custom deserializer - check if user provided a value
						if cmd.IsSet("address") {
							return fmt.Errorf("flag --address requires a custom deserializer for tui_example.DeliveryAddress (register with protocli.WithFlagDeserializer)")
						}
						// No value provided - leave field as nil
					}
				}
			}

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *ScheduledFarewellResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewFarewellServiceClient(conn)
				resp, err = client.ScheduledFarewell(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(FarewellServiceServer)
				resp, err = svcImpl.ScheduledFarewell(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getFarewellServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					// Write final newline to keep terminal clean
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if cmd.IsSet("name") {
					prefill["name"] = cmd.String("name")
				}
				if cmd.IsSet("send-at") {
					prefill["send-at"] = cmd.String("send-at")
				}
				if cmd.IsSet("address") {
					prefill["address"] = cmd.String("address")
				}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("farewell", "scheduled-farewell"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_scheduled_farewell,
		Name:  "scheduled-farewell",
		Usage: "Schedule a goodbye for a specific time and place",
	})

	// Build flags for leave-note
	flags_leave_note := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_leave_note = append(flags_leave_note, &v3.StringFlag{
		Name:     "name",
		Required: true,
		Usage:    "Name to address the note to",
	})
	flags_leave_note = append(flags_leave_note, &v3.StringFlag{
		Name:  "metadata",
		Usage: "Free-form JSON metadata",
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_leave_note = append(flags_leave_note, flagConfigured.Flags()...)
		}
	}

	flags_leave_note = append(flags_leave_note, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *NoteRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &NoteRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("name") {
					req.Name = cmd.String("name")
				}
				if cmd.IsSet("metadata") {
					req.Metadata = cmd.String("metadata")
				}
			} else {
				// Check for custom flag deserializer for tui_example.NoteRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.NoteRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					// Create FlagContainer (deserializer can access multiple flags via Command())
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					// Handle nil return from deserializer
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*NoteRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "NoteRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &NoteRequest{}
					req.Name = cmd.String("name")
					req.Metadata = cmd.String("metadata")
				}
			}

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *NoteResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewFarewellServiceClient(conn)
				resp, err = client.LeaveNote(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(FarewellServiceServer)
				resp, err = svcImpl.LeaveNote(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getFarewellServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					// Write final newline to keep terminal clean
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if cmd.IsSet("name") {
					prefill["name"] = cmd.String("name")
				}
				if cmd.IsSet("metadata") {
					prefill["metadata"] = cmd.String("metadata")
				}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("farewell", "leave-note"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_leave_note,
		Name:  "leave-note",
		Usage: "Attach a JSON note to a farewell",
	})

	// Build flags for countdown-farewell
	flags_countdown_farewell := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "delimiter",
		Usage: "Delimiter between streamed messages",
		Value: "\n",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_countdown_farewell = append(flags_countdown_farewell, &v3.StringFlag{
		Name:     "name",
		Required: true,
		Usage:    "Name to bid farewell",
	})
	flags_countdown_farewell = append(flags_countdown_farewell, &v3.Int32Flag{
		Name:  "from",
		Usage: "Countdown starting number",
		Value: int32(5),
	})
	flags_countdown_farewell = append(flags_countdown_farewell, &v3.Int32Flag{
		Name:  "delay-ms",
		Usage: "Milliseconds between countdown ticks",
		Value: int32(500),
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_countdown_farewell = append(flags_countdown_farewell, flagConfigured.Flags()...)
		}
	}

	flags_countdown_farewell = append(flags_countdown_farewell, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return fmt.Errorf("unsupported argument: %s", cmd.Args().Get(0))
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *CountdownFarewellRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &CountdownFarewellRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("name") {
					req.Name = cmd.String("name")
				}
				if cmd.IsSet("from") {
					req.From = cmd.Int32("from")
				}
				if cmd.IsSet("delay-ms") {
					req.DelayMs = cmd.Int32("delay-ms")
				}
			} else {
				// Check for custom flag deserializer for tui_example.CountdownFarewellRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.CountdownFarewellRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*CountdownFarewellRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "CountdownFarewellRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &CountdownFarewellRequest{}
					req.Name = cmd.String("name")
					req.From = cmd.Int32("from")
					req.DelayMs = cmd.Int32("delay-ms")
				}
			}

			// Open output writer
			outputWriter, err := getFarewellServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find the appropriate output format
			formatName := cmd.String("format")
			var outputFmt protocli.OutputFormat
			for _, f := range options.OutputFormats() {
				if f.Name() == formatName {
					outputFmt = f
					break
				}
			}
			if outputFmt == nil {
				var availableFormats []string
				for _, f := range options.OutputFormats() {
					availableFormats = append(availableFormats, f.Name())
				}
				return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
			}

			// Get delimiter for separating streamed messages
			delimiter := cmd.String("delimiter")

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")

			if remoteAddr != "" {
				// Remote gRPC streaming call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewFarewellServiceClient(conn)
				stream, err := client.CountdownFarewell(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("failed to start stream: %w", err)
				}

				// Receive and format each message in the stream
				var messageCount int
				for {
					msg, recvErr := stream.Recv()
					if recvErr == io.EOF {
						break
					}
					if recvErr != nil {
						return fmt.Errorf("stream receive error: %w", recvErr)
					}

					// Format and write the message
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, msg); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}

					// Write delimiter
					if _, err := outputWriter.Write([]byte(delimiter)); err != nil {
						return fmt.Errorf("failed to write delimiter: %w", err)
					}
					messageCount++
				}

				// Write final newline to keep terminal clean (only if delimiter doesn't already end with newline)
				if messageCount > 0 && !strings.HasSuffix(delimiter, "\n") {
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(FarewellServiceServer)

				// Create local stream wrapper for direct call
				localStream := &localServerStream_FarewellService_CountdownFarewell{
					ctx:       cmdCtx,
					errors:    make(chan error),
					responses: make(chan *CountdownFarewellResponse),
				}

				// Call streaming method in goroutine
				go func() {
					var methodErr error
					methodErr = svcImpl.CountdownFarewell(req, localStream)
					close(localStream.responses)
					if methodErr != nil {
						localStream.errors <- methodErr
					}
					close(localStream.errors)
				}()

				// Receive and format each message in the stream
				var messageCount int
				for {
					select {
					case msg, ok := <-localStream.responses:
						if !ok {
							// Stream closed, check for errors
							if streamErr := <-localStream.errors; streamErr != nil {
								return fmt.Errorf("stream error: %w", streamErr)
							}
							// Write final newline to keep terminal clean (only if delimiter doesn't already end with newline)
							if messageCount > 0 && !strings.HasSuffix(delimiter, "\n") {
								if _, err := outputWriter.Write([]byte("\n")); err != nil {
									return fmt.Errorf("failed to write final newline: %w", err)
								}
							}
							return nil
						}

						// Format and write the message
						if err := outputFmt.Format(cmdCtx, cmd, outputWriter, msg); err != nil {
							return fmt.Errorf("format failed: %w", err)
						}

						// Write delimiter
						if _, err := outputWriter.Write([]byte(delimiter)); err != nil {
							return fmt.Errorf("failed to write delimiter: %w", err)
						}
						messageCount++
					case <-cmdCtx.Done():
						return cmdCtx.Err()
					}
				}
			}

			return nil
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if cmd.IsSet("name") {
					prefill["name"] = cmd.String("name")
				}
				if cmd.IsSet("from") {
					prefill["from"] = strconv.FormatInt(int64(cmd.Int32("from")), 10)
				}
				if cmd.IsSet("delay-ms") {
					prefill["delay-ms"] = strconv.FormatInt(int64(cmd.Int32("delay-ms")), 10)
				}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("farewell", "countdown-farewell"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_countdown_farewell,
		Name:  "countdown-farewell",
		Usage: "Count down to a dramatic goodbye",
	})

	// Create ServiceCLI for daemonize command
	serviceCLI := &protocli.ServiceCLI{
		ConfigMessageType: "",
		FactoryOrImpl:     implOrFactory,
		RegisterFunc: func(s *grpc.Server, impl interface{}) {
			RegisterFarewellServiceServer(s, impl.(FarewellServiceServer))
		},
		ServiceName: "farewell",
	}

	// Create daemonize command for starting gRPC server
	daemonCmd := protocli.NewDaemonizeCommand(ctx, []*protocli.ServiceCLI{serviceCLI}, options)

	// Append daemonize command to the list
	commands = append(commands, daemonCmd)

	return commands
}

// getDirectoryServiceOutputWriter opens the specified output file or returns cmd.Writer (if set) or stdout
func getDirectoryServiceOutputWriter(cmd *v3.Command, path string) (io.Writer, error) {
	if path == "-" || path == "" {
		// Use cmd.Writer if set, otherwise try root command's Writer, otherwise stdout
		if cmd.Writer != nil {
			return cmd.Writer, nil
		}
		if cmd.Root().Writer != nil {
			return cmd.Root().Writer, nil
		}
		return os.Stdout, nil
	}
	return os.Create(path)
}

// localServerStream_DirectoryService_ListPeople is a helper type for local server streaming calls to ListPeople
type localServerStream_DirectoryService_ListPeople struct {
	ctx       context.Context
	responses chan *PersonCard
	errors    chan error
}

func (s *localServerStream_DirectoryService_ListPeople) Send(resp *PersonCard) error {
	select {
	case s.responses <- resp:
		return nil
	case <-s.ctx.Done():
		return s.ctx.Err()
	}
}

func (s *localServerStream_DirectoryService_ListPeople) Context() context.Context {
	return s.ctx
}

func (s *localServerStream_DirectoryService_ListPeople) SetHeader(metadata.MD) error {
	return nil
}

func (s *localServerStream_DirectoryService_ListPeople) SendHeader(metadata.MD) error {
	return nil
}

func (s *localServerStream_DirectoryService_ListPeople) SetTrailer(metadata.MD) {}

func (s *localServerStream_DirectoryService_ListPeople) SendMsg(m any) error {
	msg, ok := m.(*PersonCard)
	if !ok {
		return fmt.Errorf("invalid message type: expected *%s, got %T", "PersonCard", m)
	}
	return s.Send(msg)
}

func (s *localServerStream_DirectoryService_ListPeople) RecvMsg(m any) error {
	return fmt.Errorf("RecvMsg not supported on server streaming")
}

// DirectoryServiceCommand creates a CLI for DirectoryService with options
// The implOrFactory parameter can be either a direct service implementation or a factory function
func DirectoryServiceCommand(ctx context.Context, implOrFactory interface{}, opts ...protocli.ServiceOption) *protocli.ServiceCLI {
	options := protocli.ApplyServiceOptions(opts...)

	// Determine default format (first registered format, or empty if none)
	var defaultFormat string
	if len(options.OutputFormats()) > 0 {
		defaultFormat = options.OutputFormats()[0].Name()
	}

	var commands []*v3.Command

	// Build flags for list-people
	flags_list_people := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "delimiter",
		Usage: "Delimiter between streamed messages",
		Value: "\n",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_list_people = append(flags_list_people, &v3.StringFlag{
		Name:  "filter",
		Usage: "Filter by name prefix (leave empty for all)",
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_list_people = append(flags_list_people, flagConfigured.Flags()...)
		}
	}

	flags_list_people = append(flags_list_people, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return fmt.Errorf("unsupported argument: %s", cmd.Args().Get(0))
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *ListPeopleRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &ListPeopleRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("filter") {
					req.Filter = cmd.String("filter")
				}
			} else {
				// Check for custom flag deserializer for tui_example.ListPeopleRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.ListPeopleRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*ListPeopleRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "ListPeopleRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &ListPeopleRequest{}
					req.Filter = cmd.String("filter")
				}
			}

			// Open output writer
			outputWriter, err := getDirectoryServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find the appropriate output format
			formatName := cmd.String("format")
			var outputFmt protocli.OutputFormat
			for _, f := range options.OutputFormats() {
				if f.Name() == formatName {
					outputFmt = f
					break
				}
			}
			if outputFmt == nil {
				var availableFormats []string
				for _, f := range options.OutputFormats() {
					availableFormats = append(availableFormats, f.Name())
				}
				return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
			}

			// Get delimiter for separating streamed messages
			delimiter := cmd.String("delimiter")

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")

			if remoteAddr != "" {
				// Remote gRPC streaming call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewDirectoryServiceClient(conn)
				stream, err := client.ListPeople(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("failed to start stream: %w", err)
				}

				// Receive and format each message in the stream
				var messageCount int
				for {
					msg, recvErr := stream.Recv()
					if recvErr == io.EOF {
						break
					}
					if recvErr != nil {
						return fmt.Errorf("stream receive error: %w", recvErr)
					}

					// Format and write the message
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, msg); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}

					// Write delimiter
					if _, err := outputWriter.Write([]byte(delimiter)); err != nil {
						return fmt.Errorf("failed to write delimiter: %w", err)
					}
					messageCount++
				}

				// Write final newline to keep terminal clean (only if delimiter doesn't already end with newline)
				if messageCount > 0 && !strings.HasSuffix(delimiter, "\n") {
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(DirectoryServiceServer)

				// Create local stream wrapper for direct call
				localStream := &localServerStream_DirectoryService_ListPeople{
					ctx:       cmdCtx,
					errors:    make(chan error),
					responses: make(chan *PersonCard),
				}

				// Call streaming method in goroutine
				go func() {
					var methodErr error
					methodErr = svcImpl.ListPeople(req, localStream)
					close(localStream.responses)
					if methodErr != nil {
						localStream.errors <- methodErr
					}
					close(localStream.errors)
				}()

				// Receive and format each message in the stream
				var messageCount int
				for {
					select {
					case msg, ok := <-localStream.responses:
						if !ok {
							// Stream closed, check for errors
							if streamErr := <-localStream.errors; streamErr != nil {
								return fmt.Errorf("stream error: %w", streamErr)
							}
							// Write final newline to keep terminal clean (only if delimiter doesn't already end with newline)
							if messageCount > 0 && !strings.HasSuffix(delimiter, "\n") {
								if _, err := outputWriter.Write([]byte("\n")); err != nil {
									return fmt.Errorf("failed to write final newline: %w", err)
								}
							}
							return nil
						}

						// Format and write the message
						if err := outputFmt.Format(cmdCtx, cmd, outputWriter, msg); err != nil {
							return fmt.Errorf("format failed: %w", err)
						}

						// Write delimiter
						if _, err := outputWriter.Write([]byte(delimiter)); err != nil {
							return fmt.Errorf("failed to write delimiter: %w", err)
						}
						messageCount++
					case <-cmdCtx.Done():
						return cmdCtx.Err()
					}
				}
			}

			return nil
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if cmd.IsSet("filter") {
					prefill["filter"] = cmd.String("filter")
				}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("directory", "list-people"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_list_people,
		Name:  "list-people",
		Usage: "Browse the contact directory",
	})

	return &protocli.ServiceCLI{
		Command: &v3.Command{
			Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
				if cmd.Args().Len() > 0 {
					return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
				}
				if cmd.Bool("interactive") {
					if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtService("directory")); err != nil {
						return ctx, err
					}
					return ctx, v3.Exit("", 0)
				}
				return ctx, nil
			},
			Commands: commands,
			Flags: []v3.Flag{&v3.BoolFlag{
				Name:  "interactive",
				Usage: "Open the interactive TUI at this service",
			}},
			Name:  "directory",
			Usage: "Contact directory",
		},
		ConfigMessageType: "",
		FactoryOrImpl:     implOrFactory,
		RegisterFunc: func(s *grpc.Server, impl interface{}) {
			RegisterDirectoryServiceServer(s, impl.(DirectoryServiceServer))
		},
		ServiceName: "directory",
		TUIDescriptor: &protocli.TUIServiceDescriptor{
			Description: "Contact directory",
			DisplayName: "Directory",
			Methods: []*protocli.TUIMethodDescriptor{&protocli.TUIMethodDescriptor{
				Description: "Browse the contact directory",
				DisplayName: "Browse Directory",
				Hidden:      false,
				InputFields: []protocli.TUIFieldDescriptor{protocli.TUIFieldDescriptor{
					DefaultValue: "",
					Description:  "",
					Hidden:       false,
					Kind:         protocli.TUIFieldKindString,
					Label:        "Filter",
					Name:         "filter",
					Required:     false,
					Setter: func(msg proto.Message, s string) error {
						req := msg.(*ListPeopleRequest)
						req.Filter = s
						return nil
					},
					Usage: "Filter by name prefix (leave empty for all)",
				}},
				Invoke: func(ctx context.Context, cmd *v3.Command, req proto.Message) (proto.Message, error) {
					return nil, fmt.Errorf("use InvokeStream for server-streaming method ListPeople")
				},
				InvokeStream: func(ctx context.Context, cmd *v3.Command, req proto.Message, recv func(proto.Message) error) error {
					typedReq := req.(*ListPeopleRequest)
					typedImpl := implOrFactory.(DirectoryServiceServer)
					localStream := &localServerStream_DirectoryService_ListPeople{
						ctx:       ctx,
						errors:    make(chan error),
						responses: make(chan *PersonCard),
					}
					go func() {
						var methodErr error
						methodErr = typedImpl.ListPeople(typedReq, localStream)
						close(localStream.responses)
						if methodErr != nil {
							localStream.errors <- methodErr
						}
						close(localStream.errors)
					}()
					for {
						select {
						case msg, ok := <-localStream.responses:
							if !ok {
								if streamErr := <-localStream.errors; streamErr != nil {
									return fmt.Errorf("stream error: %w", streamErr)
								}
								return nil
							}
							if recvErr := recv(msg); recvErr != nil {
								return fmt.Errorf("recv callback failed: %w", recvErr)
							}
						case <-ctx.Done():
							return ctx.Err()
						}
					}
				},
				IsStreaming: true,
				Name:        "list-people",
				NewRequest: func() proto.Message {
					return &ListPeopleRequest{}
				},
				ResponseDescriptor: protocli.TUIResponseDescriptor{
					MessageFullName: "tui_example.PersonCard",
					MethodName:      "list-people",
				},
			}},
			Name: "directory",
		},
	}
}

// DirectoryServiceCommandsFlat creates a flat command structure for DirectoryService (for single-service CLIs)
// This returns RPC commands directly at the root level instead of nested under a service command.
// The implOrFactory parameter can be either a direct service implementation or a factory function
// The returned slice includes all RPC commands plus a daemonize command for starting a gRPC server.
func DirectoryServiceCommandsFlat(ctx context.Context, implOrFactory interface{}, opts ...protocli.ServiceOption) []*v3.Command {
	options := protocli.ApplyServiceOptions(opts...)

	// Determine default format (first registered format, or empty if none)
	var defaultFormat string
	if len(options.OutputFormats()) > 0 {
		defaultFormat = options.OutputFormats()[0].Name()
	}

	var commands []*v3.Command

	// Build flags for list-people
	flags_list_people := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "delimiter",
		Usage: "Delimiter between streamed messages",
		Value: "\n",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_list_people = append(flags_list_people, &v3.StringFlag{
		Name:  "filter",
		Usage: "Filter by name prefix (leave empty for all)",
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_list_people = append(flags_list_people, flagConfigured.Flags()...)
		}
	}

	flags_list_people = append(flags_list_people, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return fmt.Errorf("unsupported argument: %s", cmd.Args().Get(0))
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *ListPeopleRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &ListPeopleRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("filter") {
					req.Filter = cmd.String("filter")
				}
			} else {
				// Check for custom flag deserializer for tui_example.ListPeopleRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.ListPeopleRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*ListPeopleRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "ListPeopleRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &ListPeopleRequest{}
					req.Filter = cmd.String("filter")
				}
			}

			// Open output writer
			outputWriter, err := getDirectoryServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find the appropriate output format
			formatName := cmd.String("format")
			var outputFmt protocli.OutputFormat
			for _, f := range options.OutputFormats() {
				if f.Name() == formatName {
					outputFmt = f
					break
				}
			}
			if outputFmt == nil {
				var availableFormats []string
				for _, f := range options.OutputFormats() {
					availableFormats = append(availableFormats, f.Name())
				}
				return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
			}

			// Get delimiter for separating streamed messages
			delimiter := cmd.String("delimiter")

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")

			if remoteAddr != "" {
				// Remote gRPC streaming call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewDirectoryServiceClient(conn)
				stream, err := client.ListPeople(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("failed to start stream: %w", err)
				}

				// Receive and format each message in the stream
				var messageCount int
				for {
					msg, recvErr := stream.Recv()
					if recvErr == io.EOF {
						break
					}
					if recvErr != nil {
						return fmt.Errorf("stream receive error: %w", recvErr)
					}

					// Format and write the message
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, msg); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}

					// Write delimiter
					if _, err := outputWriter.Write([]byte(delimiter)); err != nil {
						return fmt.Errorf("failed to write delimiter: %w", err)
					}
					messageCount++
				}

				// Write final newline to keep terminal clean (only if delimiter doesn't already end with newline)
				if messageCount > 0 && !strings.HasSuffix(delimiter, "\n") {
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(DirectoryServiceServer)

				// Create local stream wrapper for direct call
				localStream := &localServerStream_DirectoryService_ListPeople{
					ctx:       cmdCtx,
					errors:    make(chan error),
					responses: make(chan *PersonCard),
				}

				// Call streaming method in goroutine
				go func() {
					var methodErr error
					methodErr = svcImpl.ListPeople(req, localStream)
					close(localStream.responses)
					if methodErr != nil {
						localStream.errors <- methodErr
					}
					close(localStream.errors)
				}()

				// Receive and format each message in the stream
				var messageCount int
				for {
					select {
					case msg, ok := <-localStream.responses:
						if !ok {
							// Stream closed, check for errors
							if streamErr := <-localStream.errors; streamErr != nil {
								return fmt.Errorf("stream error: %w", streamErr)
							}
							// Write final newline to keep terminal clean (only if delimiter doesn't already end with newline)
							if messageCount > 0 && !strings.HasSuffix(delimiter, "\n") {
								if _, err := outputWriter.Write([]byte("\n")); err != nil {
									return fmt.Errorf("failed to write final newline: %w", err)
								}
							}
							return nil
						}

						// Format and write the message
						if err := outputFmt.Format(cmdCtx, cmd, outputWriter, msg); err != nil {
							return fmt.Errorf("format failed: %w", err)
						}

						// Write delimiter
						if _, err := outputWriter.Write([]byte(delimiter)); err != nil {
							return fmt.Errorf("failed to write delimiter: %w", err)
						}
						messageCount++
					case <-cmdCtx.Done():
						return cmdCtx.Err()
					}
				}
			}

			return nil
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if cmd.IsSet("filter") {
					prefill["filter"] = cmd.String("filter")
				}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("directory", "list-people"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_list_people,
		Name:  "list-people",
		Usage: "Browse the contact directory",
	})

	// Create ServiceCLI for daemonize command
	serviceCLI := &protocli.ServiceCLI{
		ConfigMessageType: "",
		FactoryOrImpl:     implOrFactory,
		RegisterFunc: func(s *grpc.Server, impl interface{}) {
			RegisterDirectoryServiceServer(s, impl.(DirectoryServiceServer))
		},
		ServiceName: "directory",
	}

	// Create daemonize command for starting gRPC server
	daemonCmd := protocli.NewDaemonizeCommand(ctx, []*protocli.ServiceCLI{serviceCLI}, options)

	// Append daemonize command to the list
	commands = append(commands, daemonCmd)

	return commands
}

// getGreeterServiceOutputWriter opens the specified output file or returns cmd.Writer (if set) or stdout
func getGreeterServiceOutputWriter(cmd *v3.Command, path string) (io.Writer, error) {
	if path == "-" || path == "" {
		// Use cmd.Writer if set, otherwise try root command's Writer, otherwise stdout
		if cmd.Writer != nil {
			return cmd.Writer, nil
		}
		if cmd.Root().Writer != nil {
			return cmd.Root().Writer, nil
		}
		return os.Stdout, nil
	}
	return os.Create(path)
}

// GreeterServiceCommand creates a CLI for GreeterService with options
// The implOrFactory parameter can be either a direct service implementation or a factory function
func GreeterServiceCommand(ctx context.Context, implOrFactory interface{}, opts ...protocli.ServiceOption) *protocli.ServiceCLI {
	options := protocli.ApplyServiceOptions(opts...)

	// Determine default format (first registered format, or empty if none)
	var defaultFormat string
	if len(options.OutputFormats()) > 0 {
		defaultFormat = options.OutputFormats()[0].Name()
	}

	var commands []*v3.Command

	// Build flags for greet
	flags_greet := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_greet = append(flags_greet, &v3.StringFlag{
		Name:     "name",
		Required: true,
		Usage:    "Name to greet",
	})
	flags_greet = append(flags_greet, &v3.Int32Flag{
		Name:  "repeat",
		Usage: "Number of times to repeat the greeting",
		Value: int32(1),
	})
	flags_greet = append(flags_greet, &v3.BoolFlag{
		Name:  "loud",
		Usage: "Whether to greet loudly (all caps)",
		Value: true,
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_greet = append(flags_greet, flagConfigured.Flags()...)
		}
	}

	flags_greet = append(flags_greet, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *GreetRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &GreetRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("name") {
					req.Name = cmd.String("name")
				}
				if cmd.IsSet("repeat") {
					req.Repeat = cmd.Int32("repeat")
				}
				if cmd.IsSet("loud") {
					req.Loud = cmd.Bool("loud")
				}
			} else {
				// Check for custom flag deserializer for tui_example.GreetRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.GreetRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					// Create FlagContainer (deserializer can access multiple flags via Command())
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					// Handle nil return from deserializer
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*GreetRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "GreetRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &GreetRequest{}
					req.Name = cmd.String("name")
					req.Repeat = cmd.Int32("repeat")
					req.Loud = cmd.Bool("loud")
				}
			}

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *GreetResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewGreeterServiceClient(conn)
				resp, err = client.Greet(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(GreeterServiceServer)
				resp, err = svcImpl.Greet(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getGreeterServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					// Write final newline to keep terminal clean
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if cmd.IsSet("name") {
					prefill["name"] = cmd.String("name")
				}
				if cmd.IsSet("repeat") {
					prefill["repeat"] = strconv.FormatInt(int64(cmd.Int32("repeat")), 10)
				}
				if cmd.IsSet("loud") {
					prefill["loud"] = strconv.FormatBool(cmd.Bool("loud"))
				}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("greeter", "greet"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_greet,
		Name:  "greet",
		Usage: "Say hello to someone",
	})

	// Build flags for list-greetings
	flags_list_greetings := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_list_greetings = append(flags_list_greetings, &v3.StringSliceFlag{
		Name:  "names",
		Usage: "Names to greet (comma-separated in TUI)",
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_list_greetings = append(flags_list_greetings, flagConfigured.Flags()...)
		}
	}

	flags_list_greetings = append(flags_list_greetings, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *ListGreetingsRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &ListGreetingsRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("names") {
					req.Names = cmd.StringSlice("names")
				}
			} else {
				// Check for custom flag deserializer for tui_example.ListGreetingsRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.ListGreetingsRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					// Create FlagContainer (deserializer can access multiple flags via Command())
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					// Handle nil return from deserializer
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*ListGreetingsRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "ListGreetingsRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &ListGreetingsRequest{}
					req.Names = cmd.StringSlice("names")
				}
			}

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *ListGreetingsResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewGreeterServiceClient(conn)
				resp, err = client.ListGreetings(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(GreeterServiceServer)
				resp, err = svcImpl.ListGreetings(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getGreeterServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					// Write final newline to keep terminal clean
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("greeter", "list-greetings"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_list_greetings,
		Name:  "list-greetings",
		Usage: "Say hello to multiple people",
	})

	// Build flags for hidden
	flags_hidden := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_hidden = append(flags_hidden, &v3.StringFlag{
		Name:     "name",
		Required: true,
		Usage:    "Name to greet",
	})
	flags_hidden = append(flags_hidden, &v3.Int32Flag{
		Name:  "repeat",
		Usage: "Number of times to repeat the greeting",
		Value: int32(1),
	})
	flags_hidden = append(flags_hidden, &v3.BoolFlag{
		Name:  "loud",
		Usage: "Whether to greet loudly (all caps)",
		Value: true,
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_hidden = append(flags_hidden, flagConfigured.Flags()...)
		}
	}

	flags_hidden = append(flags_hidden, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *GreetRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &GreetRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("name") {
					req.Name = cmd.String("name")
				}
				if cmd.IsSet("repeat") {
					req.Repeat = cmd.Int32("repeat")
				}
				if cmd.IsSet("loud") {
					req.Loud = cmd.Bool("loud")
				}
			} else {
				// Check for custom flag deserializer for tui_example.GreetRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.GreetRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					// Create FlagContainer (deserializer can access multiple flags via Command())
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					// Handle nil return from deserializer
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*GreetRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "GreetRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &GreetRequest{}
					req.Name = cmd.String("name")
					req.Repeat = cmd.Int32("repeat")
					req.Loud = cmd.Bool("loud")
				}
			}

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *GreetResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewGreeterServiceClient(conn)
				resp, err = client.HiddenMethod(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(GreeterServiceServer)
				resp, err = svcImpl.HiddenMethod(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getGreeterServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					// Write final newline to keep terminal clean
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if cmd.IsSet("name") {
					prefill["name"] = cmd.String("name")
				}
				if cmd.IsSet("repeat") {
					prefill["repeat"] = strconv.FormatInt(int64(cmd.Int32("repeat")), 10)
				}
				if cmd.IsSet("loud") {
					prefill["loud"] = strconv.FormatBool(cmd.Bool("loud"))
				}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("greeter", "hidden"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_hidden,
		Name:  "hidden",
		Usage: "A method hidden from the TUI",
	})

	// Build flags for colored-greet
	flags_colored_greet := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_colored_greet = append(flags_colored_greet, &v3.StringFlag{
		Name:     "name",
		Required: true,
		Usage:    "Name to greet",
	})
	flags_colored_greet = append(flags_colored_greet, &v3.StringFlag{
		Name:  "color",
		Usage: "Greeting color as R,G,B",
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_colored_greet = append(flags_colored_greet, flagConfigured.Flags()...)
		}
	}

	flags_colored_greet = append(flags_colored_greet, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *ColoredGreetRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &ColoredGreetRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("name") {
					req.Name = cmd.String("name")
				}
				if cmd.IsSet("color") {
					if fieldDeserializer, hasFieldDeserializer := options.FlagDeserializer("tui_example.RgbColor"); hasFieldDeserializer {
						fieldFlags := protocli.NewFlagContainer(cmd, "color")
						fieldMsg, fieldErr := fieldDeserializer(cmdCtx, fieldFlags)
						if fieldErr != nil {
							return fmt.Errorf("failed to deserialize field Color: %w", fieldErr)
						}
						if fieldMsg != nil {
							typedField, fieldOk := fieldMsg.(*RgbColor)
							if !fieldOk {
								return fmt.Errorf("custom deserializer for tui_example.RgbColor returned wrong type: expected *RgbColor, got %T", fieldMsg)
							}
							req.Color = typedField
						}
					} else {
						return fmt.Errorf("flag --color requires a custom deserializer for tui_example.RgbColor (register with protocli.WithFlagDeserializer)")
					}
				}
			} else {
				// Check for custom flag deserializer for tui_example.ColoredGreetRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.ColoredGreetRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					// Create FlagContainer (deserializer can access multiple flags via Command())
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					// Handle nil return from deserializer
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*ColoredGreetRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "ColoredGreetRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &ColoredGreetRequest{}
					req.Name = cmd.String("name")
					// Field Color: check for custom deserializer for tui_example.RgbColor
					if fieldDeserializer, hasFieldDeserializer := options.FlagDeserializer("tui_example.RgbColor"); hasFieldDeserializer {
						// Use custom deserializer for nested message
						// Create FlagContainer for field flag: color
						fieldFlags := protocli.NewFlagContainer(cmd, "color")
						fieldMsg, fieldErr := fieldDeserializer(cmdCtx, fieldFlags)
						if fieldErr != nil {
							return fmt.Errorf("failed to deserialize field Color: %w", fieldErr)
						}
						// Handle nil return from deserializer (means skip/use default)
						if fieldMsg != nil {
							typedField, fieldOk := fieldMsg.(*RgbColor)
							if !fieldOk {
								return fmt.Errorf("custom deserializer for tui_example.RgbColor returned wrong type: expected *RgbColor, got %T", fieldMsg)
							}
							req.Color = typedField
						}
					} else {
						// No custom deserializer - check if user provided a value
						if cmd.IsSet("color") {
							return fmt.Errorf("flag --color requires a custom deserializer for tui_example.RgbColor (register with protocli.WithFlagDeserializer)")
						}
						// No value provided - leave field as nil
					}
				}
			}

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *ColoredGreetResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewGreeterServiceClient(conn)
				resp, err = client.ColoredGreet(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(GreeterServiceServer)
				resp, err = svcImpl.ColoredGreet(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getGreeterServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					// Write final newline to keep terminal clean
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if cmd.IsSet("name") {
					prefill["name"] = cmd.String("name")
				}
				if cmd.IsSet("color") {
					prefill["color"] = cmd.String("color")
				}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("greeter", "colored-greet"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_colored_greet,
		Name:  "colored-greet",
		Usage: "Say hello in a chosen color",
	})

	// Build flags for schedule-call
	flags_schedule_call := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_schedule_call = append(flags_schedule_call, &v3.StringFlag{
		Name:     "with",
		Required: true,
		Usage:    "Who to call",
	})
	flags_schedule_call = append(flags_schedule_call, &v3.StringFlag{
		Name:     "when",
		Required: true,
		Usage:    "When to call  enter in local time",
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_schedule_call = append(flags_schedule_call, flagConfigured.Flags()...)
		}
	}

	flags_schedule_call = append(flags_schedule_call, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *ScheduleCallRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &ScheduleCallRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("with") {
					req.With = cmd.String("with")
				}
				if cmd.IsSet("when") {
					if fieldDeserializer, hasFieldDeserializer := options.FlagDeserializer("google.protobuf.Timestamp"); hasFieldDeserializer {
						fieldFlags := protocli.NewFlagContainer(cmd, "when")
						fieldMsg, fieldErr := fieldDeserializer(cmdCtx, fieldFlags)
						if fieldErr != nil {
							return fmt.Errorf("failed to deserialize field When: %w", fieldErr)
						}
						if fieldMsg != nil {
							typedField, fieldOk := fieldMsg.(*timestamppb.Timestamp)
							if !fieldOk {
								return fmt.Errorf("custom deserializer for google.protobuf.Timestamp returned wrong type: expected *Timestamp, got %T", fieldMsg)
							}
							req.When = typedField
						}
					} else {
						return fmt.Errorf("flag --when requires a custom deserializer for google.protobuf.Timestamp (register with protocli.WithFlagDeserializer)")
					}
				}
			} else {
				// Check for custom flag deserializer for tui_example.ScheduleCallRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.ScheduleCallRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					// Create FlagContainer (deserializer can access multiple flags via Command())
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					// Handle nil return from deserializer
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*ScheduleCallRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "ScheduleCallRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &ScheduleCallRequest{}
					req.With = cmd.String("with")
					// Field When: check for custom deserializer for google.protobuf.Timestamp
					if fieldDeserializer, hasFieldDeserializer := options.FlagDeserializer("google.protobuf.Timestamp"); hasFieldDeserializer {
						// Use custom deserializer for nested message
						// Create FlagContainer for field flag: when
						fieldFlags := protocli.NewFlagContainer(cmd, "when")
						fieldMsg, fieldErr := fieldDeserializer(cmdCtx, fieldFlags)
						if fieldErr != nil {
							return fmt.Errorf("failed to deserialize field When: %w", fieldErr)
						}
						// Handle nil return from deserializer (means skip/use default)
						if fieldMsg != nil {
							typedField, fieldOk := fieldMsg.(*timestamppb.Timestamp)
							if !fieldOk {
								return fmt.Errorf("custom deserializer for google.protobuf.Timestamp returned wrong type: expected *Timestamp, got %T", fieldMsg)
							}
							req.When = typedField
						}
					} else {
						// No custom deserializer - check if user provided a value
						if cmd.IsSet("when") {
							return fmt.Errorf("flag --when requires a custom deserializer for google.protobuf.Timestamp (register with protocli.WithFlagDeserializer)")
						}
						// No value provided - leave field as nil
					}
				}
			}

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *ScheduleCallResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewGreeterServiceClient(conn)
				resp, err = client.ScheduleCall(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(GreeterServiceServer)
				resp, err = svcImpl.ScheduleCall(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getGreeterServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					// Write final newline to keep terminal clean
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if cmd.IsSet("with") {
					prefill["with"] = cmd.String("with")
				}
				if cmd.IsSet("when") {
					prefill["when"] = cmd.String("when")
				}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("greeter", "schedule-call"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_schedule_call,
		Name:  "schedule-call",
		Usage: "Book a call in your local timezone",
	})

	return &protocli.ServiceCLI{
		Command: &v3.Command{
			Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
				if cmd.Args().Len() > 0 {
					return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
				}
				if cmd.Bool("interactive") {
					if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtService("greeter")); err != nil {
						return ctx, err
					}
					return ctx, v3.Exit("", 0)
				}
				return ctx, nil
			},
			Commands: commands,
			Flags: []v3.Flag{&v3.BoolFlag{
				Name:  "interactive",
				Usage: "Open the interactive TUI at this service",
			}},
			Name:  "greeter",
			Usage: "Greeting commands",
		},
		ConfigMessageType: "",
		FactoryOrImpl:     implOrFactory,
		RegisterFunc: func(s *grpc.Server, impl interface{}) {
			RegisterGreeterServiceServer(s, impl.(GreeterServiceServer))
		},
		ServiceName: "greeter",
		TUIDescriptor: &protocli.TUIServiceDescriptor{
			Description: "Greeting commands",
			DisplayName: "Greeter",
			Methods: []*protocli.TUIMethodDescriptor{&protocli.TUIMethodDescriptor{
				Description: "Say hello to someone",
				DisplayName: "Say Hello",
				Hidden:      false,
				InputFields: []protocli.TUIFieldDescriptor{protocli.TUIFieldDescriptor{
					DefaultValue: "",
					Description:  "",
					Hidden:       false,
					Kind:         protocli.TUIFieldKindString,
					Label:        "Name",
					Name:         "name",
					Required:     true,
					Setter: func(msg proto.Message, s string) error {
						req := msg.(*GreetRequest)
						req.Name = s
						return nil
					},
					Usage: "Name to greet",
				}, protocli.TUIFieldDescriptor{
					DefaultValue: "1",
					Description:  "",
					Hidden:       false,
					Kind:         protocli.TUIFieldKindInt,
					Label:        "Repeat",
					Name:         "repeat",
					Required:     false,
					Setter: func(msg proto.Message, s string) error {
						req := msg.(*GreetRequest)
						n, err := strconv.ParseInt(s, 10, 32)
						if err != nil {
							return fmt.Errorf("invalid int32 for repeat: %w", err)
						}
						req.Repeat = int32(n)
						return nil
					},
					Usage: "Number of times to repeat the greeting",
				}, protocli.TUIFieldDescriptor{
					DefaultValue: "true",
					Description:  "",
					Hidden:       false,
					Kind:         protocli.TUIFieldKindBool,
					Label:        "Loud",
					Name:         "loud",
					Required:     false,
					Setter: func(msg proto.Message, s string) error {
						req := msg.(*GreetRequest)
						v, err := strconv.ParseBool(s)
						if err != nil {
							return fmt.Errorf("invalid bool for loud: %w", err)
						}
						req.Loud = v
						return nil
					},
					Usage: "Whether to greet loudly (all caps)",
				}},
				Invoke: func(ctx context.Context, cmd *v3.Command, req proto.Message) (proto.Message, error) {
					typedReq := req.(*GreetRequest)
					svcImpl := implOrFactory.(GreeterServiceServer)
					resp, err := svcImpl.Greet(ctx, typedReq)
					if err != nil {
						return nil, fmt.Errorf("method failed: %w", err)
					}
					return proto.Message(resp), nil
				},
				IsStreaming: false,
				Name:        "greet",
				NewRequest: func() proto.Message {
					return &GreetRequest{}
				},
				ResponseDescriptor: protocli.TUIResponseDescriptor{
					MessageFullName: "tui_example.GreetResponse",
					MethodName:      "greet",
				},
			}, &protocli.TUIMethodDescriptor{
				Description: "Say hello to multiple people",
				DisplayName: "Greet Many",
				Hidden:      false,
				InputFields: []protocli.TUIFieldDescriptor{protocli.TUIFieldDescriptor{
					Appender: func(msg proto.Message, s string) error {
						req := msg.(*ListGreetingsRequest)
						req.Names = append(req.Names, s)
						return nil
					},
					DefaultValue: "",
					Description:  "",
					ElementKind:  protocli.TUIFieldKindString,
					Hidden:       false,
					Kind:         protocli.TUIFieldKindRepeated,
					Label:        "Names",
					Name:         "names",
					Required:     false,
					Usage:        "Names to greet (comma-separated in TUI)",
				}},
				Invoke: func(ctx context.Context, cmd *v3.Command, req proto.Message) (proto.Message, error) {
					typedReq := req.(*ListGreetingsRequest)
					svcImpl := implOrFactory.(GreeterServiceServer)
					resp, err := svcImpl.ListGreetings(ctx, typedReq)
					if err != nil {
						return nil, fmt.Errorf("method failed: %w", err)
					}
					return proto.Message(resp), nil
				},
				IsStreaming: false,
				Name:        "list-greetings",
				NewRequest: func() proto.Message {
					return &ListGreetingsRequest{}
				},
				ResponseDescriptor: protocli.TUIResponseDescriptor{
					MessageFullName: "tui_example.ListGreetingsResponse",
					MethodName:      "list-greetings",
				},
			}, &protocli.TUIMethodDescriptor{
				Description: "A method hidden from the TUI",
				DisplayName: "HiddenMethod",
				Hidden:      true,
				InputFields: []protocli.TUIFieldDescriptor{protocli.TUIFieldDescriptor{
					DefaultValue: "",
					Description:  "",
					Hidden:       false,
					Kind:         protocli.TUIFieldKindString,
					Label:        "Name",
					Name:         "name",
					Required:     true,
					Setter: func(msg proto.Message, s string) error {
						req := msg.(*GreetRequest)
						req.Name = s
						return nil
					},
					Usage: "Name to greet",
				}, protocli.TUIFieldDescriptor{
					DefaultValue: "1",
					Description:  "",
					Hidden:       false,
					Kind:         protocli.TUIFieldKindInt,
					Label:        "Repeat",
					Name:         "repeat",
					Required:     false,
					Setter: func(msg proto.Message, s string) error {
						req := msg.(*GreetRequest)
						n, err := strconv.ParseInt(s, 10, 32)
						if err != nil {
							return fmt.Errorf("invalid int32 for repeat: %w", err)
						}
						req.Repeat = int32(n)
						return nil
					},
					Usage: "Number of times to repeat the greeting",
				}, protocli.TUIFieldDescriptor{
					DefaultValue: "true",
					Description:  "",
					Hidden:       false,
					Kind:         protocli.TUIFieldKindBool,
					Label:        "Loud",
					Name:         "loud",
					Required:     false,
					Setter: func(msg proto.Message, s string) error {
						req := msg.(*GreetRequest)
						v, err := strconv.ParseBool(s)
						if err != nil {
							return fmt.Errorf("invalid bool for loud: %w", err)
						}
						req.Loud = v
						return nil
					},
					Usage: "Whether to greet loudly (all caps)",
				}},
				Invoke: func(ctx context.Context, cmd *v3.Command, req proto.Message) (proto.Message, error) {
					typedReq := req.(*GreetRequest)
					svcImpl := implOrFactory.(GreeterServiceServer)
					resp, err := svcImpl.HiddenMethod(ctx, typedReq)
					if err != nil {
						return nil, fmt.Errorf("method failed: %w", err)
					}
					return proto.Message(resp), nil
				},
				IsStreaming: false,
				Name:        "hidden",
				NewRequest: func() proto.Message {
					return &GreetRequest{}
				},
				ResponseDescriptor: protocli.TUIResponseDescriptor{
					MessageFullName: "tui_example.GreetResponse",
					MethodName:      "hidden",
				},
			}, &protocli.TUIMethodDescriptor{
				Description: "Say hello in a chosen color",
				DisplayName: "ColoredGreet",
				Hidden:      false,
				InputFields: []protocli.TUIFieldDescriptor{protocli.TUIFieldDescriptor{
					DefaultValue: "",
					Description:  "",
					Hidden:       false,
					Kind:         protocli.TUIFieldKindString,
					Label:        "Name",
					Name:         "name",
					Required:     true,
					Setter: func(msg proto.Message, s string) error {
						req := msg.(*ColoredGreetRequest)
						req.Name = s
						return nil
					},
					Usage: "Name to greet",
				}, protocli.TUIFieldDescriptor{
					DefaultValue: "",
					Description:  "",
					Fields: []protocli.TUIFieldDescriptor{protocli.TUIFieldDescriptor{
						DefaultValue: "",
						Description:  "",
						Hidden:       false,
						Kind:         protocli.TUIFieldKindInt,
						Label:        "Red",
						Name:         "r",
						Required:     false,
						Setter: func(msg proto.Message, s string) error {
							req := msg.(*ColoredGreetRequest)
							if req.Color == nil {
								req.Color = &RgbColor{}
							}
							n, err := strconv.ParseInt(s, 10, 32)
							if err != nil {
								return fmt.Errorf("invalid int32 for r: %w", err)
							}
							req.Color.R = int32(n)
							return nil
						},
						Usage: "Red channel (0-255)",
					}, protocli.TUIFieldDescriptor{
						DefaultValue: "",
						Description:  "",
						Hidden:       false,
						Kind:         protocli.TUIFieldKindInt,
						Label:        "Green",
						Name:         "g",
						Required:     false,
						Setter: func(msg proto.Message, s string) error {
							req := msg.(*ColoredGreetRequest)
							if req.Color == nil {
								req.Color = &RgbColor{}
							}
							n, err := strconv.ParseInt(s, 10, 32)
							if err != nil {
								return fmt.Errorf("invalid int32 for g: %w", err)
							}
							req.Color.G = int32(n)
							return nil
						},
						Usage: "Green channel (0-255)",
					}, protocli.TUIFieldDescriptor{
						DefaultValue: "",
						Description:  "",
						Hidden:       false,
						Kind:         protocli.TUIFieldKindInt,
						Label:        "Blue",
						Name:         "b",
						Required:     false,
						Setter: func(msg proto.Message, s string) error {
							req := msg.(*ColoredGreetRequest)
							if req.Color == nil {
								req.Color = &RgbColor{}
							}
							n, err := strconv.ParseInt(s, 10, 32)
							if err != nil {
								return fmt.Errorf("invalid int32 for b: %w", err)
							}
							req.Color.B = int32(n)
							return nil
						},
						Usage: "Blue channel (0-255)",
					}},
					Hidden:          false,
					Kind:            protocli.TUIFieldKindMessage,
					Label:           "Color",
					MessageFullName: "tui_example.RgbColor",
					Name:            "color",
					Required:        false,
					Usage:           "Greeting color as R,G,B",
				}},
				Invoke: func(ctx context.Context, cmd *v3.Command, req proto.Message) (proto.Message, error) {
					typedReq := req.(*ColoredGreetRequest)
					svcImpl := implOrFactory.(GreeterServiceServer)
					resp, err := svcImpl.ColoredGreet(ctx, typedReq)
					if err != nil {
						return nil, fmt.Errorf("method failed: %w", err)
					}
					return proto.Message(resp), nil
				},
				IsStreaming: false,
				Name:        "colored-greet",
				NewRequest: func() proto.Message {
					return &ColoredGreetRequest{}
				},
				ResponseDescriptor: protocli.TUIResponseDescriptor{
					MessageFullName: "tui_example.ColoredGreetResponse",
					MethodName:      "colored-greet",
				},
			}, &protocli.TUIMethodDescriptor{
				Description: "Book a call in your local timezone",
				DisplayName: "Schedule a Call",
				Hidden:      false,
				InputFields: []protocli.TUIFieldDescriptor{protocli.TUIFieldDescriptor{
					DefaultValue: "",
					Description:  "",
					Hidden:       false,
					Kind:         protocli.TUIFieldKindString,
					Label:        "With",
					Name:         "with",
					Required:     true,
					Setter: func(msg proto.Message, s string) error {
						req := msg.(*ScheduleCallRequest)
						req.With = s
						return nil
					},
					Usage: "Who to call",
				}, protocli.TUIFieldDescriptor{
					DefaultValue:    "",
					Description:     "",
					Hidden:          false,
					Kind:            protocli.TUIFieldKindString,
					Label:           "When",
					MessageFullName: "google.protobuf.Timestamp",
					Name:            "when",
					Required:        true,
					Setter: func(msg proto.Message, s string) error {
						req := msg.(*ScheduleCallRequest)
						t, err := time.Parse(time.RFC3339, s)
						if err != nil {
							return fmt.Errorf("invalid RFC3339 timestamp for when: %w", err)
						}
						req.When = timestamppb.New(t)
						return nil
					},
					Usage: "When to call  enter in local time",
				}},
				Invoke: func(ctx context.Context, cmd *v3.Command, req proto.Message) (proto.Message, error) {
					typedReq := req.(*ScheduleCallRequest)
					svcImpl := implOrFactory.(GreeterServiceServer)
					resp, err := svcImpl.ScheduleCall(ctx, typedReq)
					if err != nil {
						return nil, fmt.Errorf("method failed: %w", err)
					}
					return proto.Message(resp), nil
				},
				IsStreaming: false,
				Name:        "schedule-call",
				NewRequest: func() proto.Message {
					return &ScheduleCallRequest{}
				},
				ResponseDescriptor: protocli.TUIResponseDescriptor{
					MessageFullName: "tui_example.ScheduleCallResponse",
					MethodName:      "schedule-call",
				},
			}},
			Name: "greeter",
		},
	}
}

// GreeterServiceCommandsFlat creates a flat command structure for GreeterService (for single-service CLIs)
// This returns RPC commands directly at the root level instead of nested under a service command.
// The implOrFactory parameter can be either a direct service implementation or a factory function
// The returned slice includes all RPC commands plus a daemonize command for starting a gRPC server.
func GreeterServiceCommandsFlat(ctx context.Context, implOrFactory interface{}, opts ...protocli.ServiceOption) []*v3.Command {
	options := protocli.ApplyServiceOptions(opts...)

	// Determine default format (first registered format, or empty if none)
	var defaultFormat string
	if len(options.OutputFormats()) > 0 {
		defaultFormat = options.OutputFormats()[0].Name()
	}

	var commands []*v3.Command

	// Build flags for greet
	flags_greet := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_greet = append(flags_greet, &v3.StringFlag{
		Name:     "name",
		Required: true,
		Usage:    "Name to greet",
	})
	flags_greet = append(flags_greet, &v3.Int32Flag{
		Name:  "repeat",
		Usage: "Number of times to repeat the greeting",
		Value: int32(1),
	})
	flags_greet = append(flags_greet, &v3.BoolFlag{
		Name:  "loud",
		Usage: "Whether to greet loudly (all caps)",
		Value: true,
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_greet = append(flags_greet, flagConfigured.Flags()...)
		}
	}

	flags_greet = append(flags_greet, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *GreetRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &GreetRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("name") {
					req.Name = cmd.String("name")
				}
				if cmd.IsSet("repeat") {
					req.Repeat = cmd.Int32("repeat")
				}
				if cmd.IsSet("loud") {
					req.Loud = cmd.Bool("loud")
				}
			} else {
				// Check for custom flag deserializer for tui_example.GreetRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.GreetRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					// Create FlagContainer (deserializer can access multiple flags via Command())
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					// Handle nil return from deserializer
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*GreetRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "GreetRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &GreetRequest{}
					req.Name = cmd.String("name")
					req.Repeat = cmd.Int32("repeat")
					req.Loud = cmd.Bool("loud")
				}
			}

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *GreetResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewGreeterServiceClient(conn)
				resp, err = client.Greet(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(GreeterServiceServer)
				resp, err = svcImpl.Greet(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getGreeterServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					// Write final newline to keep terminal clean
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if cmd.IsSet("name") {
					prefill["name"] = cmd.String("name")
				}
				if cmd.IsSet("repeat") {
					prefill["repeat"] = strconv.FormatInt(int64(cmd.Int32("repeat")), 10)
				}
				if cmd.IsSet("loud") {
					prefill["loud"] = strconv.FormatBool(cmd.Bool("loud"))
				}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("greeter", "greet"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_greet,
		Name:  "greet",
		Usage: "Say hello to someone",
	})

	// Build flags for list-greetings
	flags_list_greetings := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_list_greetings = append(flags_list_greetings, &v3.StringSliceFlag{
		Name:  "names",
		Usage: "Names to greet (comma-separated in TUI)",
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_list_greetings = append(flags_list_greetings, flagConfigured.Flags()...)
		}
	}

	flags_list_greetings = append(flags_list_greetings, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *ListGreetingsRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &ListGreetingsRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("names") {
					req.Names = cmd.StringSlice("names")
				}
			} else {
				// Check for custom flag deserializer for tui_example.ListGreetingsRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.ListGreetingsRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					// Create FlagContainer (deserializer can access multiple flags via Command())
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					// Handle nil return from deserializer
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*ListGreetingsRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "ListGreetingsRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &ListGreetingsRequest{}
					req.Names = cmd.StringSlice("names")
				}
			}

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *ListGreetingsResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewGreeterServiceClient(conn)
				resp, err = client.ListGreetings(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(GreeterServiceServer)
				resp, err = svcImpl.ListGreetings(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getGreeterServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					// Write final newline to keep terminal clean
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("greeter", "list-greetings"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_list_greetings,
		Name:  "list-greetings",
		Usage: "Say hello to multiple people",
	})

	// Build flags for hidden
	flags_hidden := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_hidden = append(flags_hidden, &v3.StringFlag{
		Name:     "name",
		Required: true,
		Usage:    "Name to greet",
	})
	flags_hidden = append(flags_hidden, &v3.Int32Flag{
		Name:  "repeat",
		Usage: "Number of times to repeat the greeting",
		Value: int32(1),
	})
	flags_hidden = append(flags_hidden, &v3.BoolFlag{
		Name:  "loud",
		Usage: "Whether to greet loudly (all caps)",
		Value: true,
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_hidden = append(flags_hidden, flagConfigured.Flags()...)
		}
	}

	flags_hidden = append(flags_hidden, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *GreetRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &GreetRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("name") {
					req.Name = cmd.String("name")
				}
				if cmd.IsSet("repeat") {
					req.Repeat = cmd.Int32("repeat")
				}
				if cmd.IsSet("loud") {
					req.Loud = cmd.Bool("loud")
				}
			} else {
				// Check for custom flag deserializer for tui_example.GreetRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.GreetRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					// Create FlagContainer (deserializer can access multiple flags via Command())
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					// Handle nil return from deserializer
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*GreetRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "GreetRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &GreetRequest{}
					req.Name = cmd.String("name")
					req.Repeat = cmd.Int32("repeat")
					req.Loud = cmd.Bool("loud")
				}
			}

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *GreetResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewGreeterServiceClient(conn)
				resp, err = client.HiddenMethod(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(GreeterServiceServer)
				resp, err = svcImpl.HiddenMethod(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getGreeterServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					// Write final newline to keep terminal clean
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if cmd.IsSet("name") {
					prefill["name"] = cmd.String("name")
				}
				if cmd.IsSet("repeat") {
					prefill["repeat"] = strconv.FormatInt(int64(cmd.Int32("repeat")), 10)
				}
				if cmd.IsSet("loud") {
					prefill["loud"] = strconv.FormatBool(cmd.Bool("loud"))
				}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("greeter", "hidden"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_hidden,
		Name:  "hidden",
		Usage: "A method hidden from the TUI",
	})

	// Build flags for colored-greet
	flags_colored_greet := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_colored_greet = append(flags_colored_greet, &v3.StringFlag{
		Name:     "name",
		Required: true,
		Usage:    "Name to greet",
	})
	flags_colored_greet = append(flags_colored_greet, &v3.StringFlag{
		Name:  "color",
		Usage: "Greeting color as R,G,B",
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_colored_greet = append(flags_colored_greet, flagConfigured.Flags()...)
		}
	}

	flags_colored_greet = append(flags_colored_greet, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *ColoredGreetRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &ColoredGreetRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("name") {
					req.Name = cmd.String("name")
				}
				if cmd.IsSet("color") {
					if fieldDeserializer, hasFieldDeserializer := options.FlagDeserializer("tui_example.RgbColor"); hasFieldDeserializer {
						fieldFlags := protocli.NewFlagContainer(cmd, "color")
						fieldMsg, fieldErr := fieldDeserializer(cmdCtx, fieldFlags)
						if fieldErr != nil {
							return fmt.Errorf("failed to deserialize field Color: %w", fieldErr)
						}
						if fieldMsg != nil {
							typedField, fieldOk := fieldMsg.(*RgbColor)
							if !fieldOk {
								return fmt.Errorf("custom deserializer for tui_example.RgbColor returned wrong type: expected *RgbColor, got %T", fieldMsg)
							}
							req.Color = typedField
						}
					} else {
						return fmt.Errorf("flag --color requires a custom deserializer for tui_example.RgbColor (register with protocli.WithFlagDeserializer)")
					}
				}
			} else {
				// Check for custom flag deserializer for tui_example.ColoredGreetRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.ColoredGreetRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					// Create FlagContainer (deserializer can access multiple flags via Command())
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					// Handle nil return from deserializer
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*ColoredGreetRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "ColoredGreetRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &ColoredGreetRequest{}
					req.Name = cmd.String("name")
					// Field Color: check for custom deserializer for tui_example.RgbColor
					if fieldDeserializer, hasFieldDeserializer := options.FlagDeserializer("tui_example.RgbColor"); hasFieldDeserializer {
						// Use custom deserializer for nested message
						// Create FlagContainer for field flag: color
						fieldFlags := protocli.NewFlagContainer(cmd, "color")
						fieldMsg, fieldErr := fieldDeserializer(cmdCtx, fieldFlags)
						if fieldErr != nil {
							return fmt.Errorf("failed to deserialize field Color: %w", fieldErr)
						}
						// Handle nil return from deserializer (means skip/use default)
						if fieldMsg != nil {
							typedField, fieldOk := fieldMsg.(*RgbColor)
							if !fieldOk {
								return fmt.Errorf("custom deserializer for tui_example.RgbColor returned wrong type: expected *RgbColor, got %T", fieldMsg)
							}
							req.Color = typedField
						}
					} else {
						// No custom deserializer - check if user provided a value
						if cmd.IsSet("color") {
							return fmt.Errorf("flag --color requires a custom deserializer for tui_example.RgbColor (register with protocli.WithFlagDeserializer)")
						}
						// No value provided - leave field as nil
					}
				}
			}

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *ColoredGreetResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewGreeterServiceClient(conn)
				resp, err = client.ColoredGreet(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(GreeterServiceServer)
				resp, err = svcImpl.ColoredGreet(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getGreeterServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					// Write final newline to keep terminal clean
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if cmd.IsSet("name") {
					prefill["name"] = cmd.String("name")
				}
				if cmd.IsSet("color") {
					prefill["color"] = cmd.String("color")
				}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("greeter", "colored-greet"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_colored_greet,
		Name:  "colored-greet",
		Usage: "Say hello in a chosen color",
	})

	// Build flags for schedule-call
	flags_schedule_call := []v3.Flag{&v3.StringFlag{
		Name:  "remote",
		Usage: "Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call",
	}, &v3.StringFlag{
		Name:  "format",
		Usage: "Output format (use --format to see available formats)",
		Value: defaultFormat,
	}, &v3.StringFlag{
		Name:  "output",
		Usage: "Output file (- for stdout)",
		Value: "-",
	}, &v3.StringFlag{
		Name:  "input-file",
		Usage: "Read request from file (JSON or YAML). CLI flags override file values",
	}, &v3.StringFlag{
		Name:  "input-format",
		Usage: "Input file format (auto-detected from extension if not set)",
	}}

	flags_schedule_call = append(flags_schedule_call, &v3.StringFlag{
		Name:     "with",
		Required: true,
		Usage:    "Who to call",
	})
	flags_schedule_call = append(flags_schedule_call, &v3.StringFlag{
		Name:     "when",
		Required: true,
		Usage:    "When to call  enter in local time",
	})

	// Add format-specific flags from registered formats
	for _, outputFmt := range options.OutputFormats() {
		// Check if format implements FlagConfiguredOutputFormat
		if flagConfigured, ok := outputFmt.(protocli.FlagConfiguredOutputFormat); ok {
			flags_schedule_call = append(flags_schedule_call, flagConfigured.Flags()...)
		}
	}

	flags_schedule_call = append(flags_schedule_call, &v3.BoolFlag{
		Name:  "interactive",
		Usage: "Open the interactive TUI at this method's form",
	})
	commands = append(commands, &v3.Command{
		Action: func(cmdCtx context.Context, cmd *v3.Command) error {
			if cmd.Args().Len() > 0 {
				return v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}

			defer func() {
				hooks := options.AfterCommandHooks()
				for i := len(hooks) - 1; i >= 0; i-- {
					if err := hooks[i](cmdCtx, cmd); err != nil {
						slog.Warn("after hook failed", "error", err)
					}
				}
			}()

			for _, hook := range options.BeforeCommandHooks() {
				if err := hook(cmdCtx, cmd); err != nil {
					return fmt.Errorf("before hook failed: %w", err)
				}
			}

			// Build request message
			var req *ScheduleCallRequest

			// Check for file-based input
			inputFile := cmd.String("input-file")
			if inputFile != "" {
				// Read request from file
				req = &ScheduleCallRequest{}
				if err := protocli.ReadInputFile(inputFile, cmd.String("input-format"), options.InputFormats(), req); err != nil {
					return err
				}
				// Apply flag overrides (only explicitly-set flags)
				if cmd.IsSet("with") {
					req.With = cmd.String("with")
				}
				if cmd.IsSet("when") {
					if fieldDeserializer, hasFieldDeserializer := options.FlagDeserializer("google.protobuf.Timestamp"); hasFieldDeserializer {
						fieldFlags := protocli.NewFlagContainer(cmd, "when")
						fieldMsg, fieldErr := fieldDeserializer(cmdCtx, fieldFlags)
						if fieldErr != nil {
							return fmt.Errorf("failed to deserialize field When: %w", fieldErr)
						}
						if fieldMsg != nil {
							typedField, fieldOk := fieldMsg.(*timestamppb.Timestamp)
							if !fieldOk {
								return fmt.Errorf("custom deserializer for google.protobuf.Timestamp returned wrong type: expected *Timestamp, got %T", fieldMsg)
							}
							req.When = typedField
						}
					} else {
						return fmt.Errorf("flag --when requires a custom deserializer for google.protobuf.Timestamp (register with protocli.WithFlagDeserializer)")
					}
				}
			} else {
				// Check for custom flag deserializer for tui_example.ScheduleCallRequest
				deserializer, hasDeserializer := options.FlagDeserializer("tui_example.ScheduleCallRequest")
				if hasDeserializer {
					// Use custom deserializer for top-level request
					// Create FlagContainer (deserializer can access multiple flags via Command())
					requestFlags := protocli.NewFlagContainer(cmd, "")
					msg, err := deserializer(cmdCtx, requestFlags)
					if err != nil {
						return fmt.Errorf("custom deserializer failed: %w", err)
					}
					// Handle nil return from deserializer
					if msg == nil {
						return fmt.Errorf("custom deserializer returned nil message")
					}
					var ok bool
					req, ok = msg.(*ScheduleCallRequest)
					if !ok {
						return fmt.Errorf("custom deserializer returned wrong type: expected *%s, got %T", "ScheduleCallRequest", msg)
					}
				} else {
					// Use auto-generated flag parsing
					req = &ScheduleCallRequest{}
					req.With = cmd.String("with")
					// Field When: check for custom deserializer for google.protobuf.Timestamp
					if fieldDeserializer, hasFieldDeserializer := options.FlagDeserializer("google.protobuf.Timestamp"); hasFieldDeserializer {
						// Use custom deserializer for nested message
						// Create FlagContainer for field flag: when
						fieldFlags := protocli.NewFlagContainer(cmd, "when")
						fieldMsg, fieldErr := fieldDeserializer(cmdCtx, fieldFlags)
						if fieldErr != nil {
							return fmt.Errorf("failed to deserialize field When: %w", fieldErr)
						}
						// Handle nil return from deserializer (means skip/use default)
						if fieldMsg != nil {
							typedField, fieldOk := fieldMsg.(*timestamppb.Timestamp)
							if !fieldOk {
								return fmt.Errorf("custom deserializer for google.protobuf.Timestamp returned wrong type: expected *Timestamp, got %T", fieldMsg)
							}
							req.When = typedField
						}
					} else {
						// No custom deserializer - check if user provided a value
						if cmd.IsSet("when") {
							return fmt.Errorf("flag --when requires a custom deserializer for google.protobuf.Timestamp (register with protocli.WithFlagDeserializer)")
						}
						// No value provided - leave field as nil
					}
				}
			}

			// Check if using remote gRPC call or direct implementation call
			remoteAddr := cmd.String("remote")
			var resp *ScheduleCallResponse
			var err error

			if remoteAddr != "" {
				// Remote gRPC call
				conn, connErr := grpc.NewClient(remoteAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
				if connErr != nil {
					return fmt.Errorf("failed to connect to remote %s: %w", remoteAddr, connErr)
				}
				defer conn.Close()

				client := NewGreeterServiceClient(conn)
				resp, err = client.ScheduleCall(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("remote call failed: %w", err)
				}
			} else {
				// Direct implementation call (no config)
				svcImpl := implOrFactory.(GreeterServiceServer)
				resp, err = svcImpl.ScheduleCall(cmdCtx, req)
				if err != nil {
					return fmt.Errorf("method failed: %w", err)
				}
			}

			// Open output writer
			outputWriter, err := getGreeterServiceOutputWriter(cmd, cmd.String("output"))
			if err != nil {
				return fmt.Errorf("failed to open output: %w", err)
			}
			if closer, ok := outputWriter.(io.Closer); ok {
				defer closer.Close()
			}

			// Find and use the appropriate output format
			formatName := cmd.String("format")

			// Try registered formats
			for _, outputFmt := range options.OutputFormats() {
				if outputFmt.Name() == formatName {
					if err := outputFmt.Format(cmdCtx, cmd, outputWriter, resp); err != nil {
						return fmt.Errorf("format failed: %w", err)
					}
					// Write final newline to keep terminal clean
					if _, err := outputWriter.Write([]byte("\n")); err != nil {
						return fmt.Errorf("failed to write final newline: %w", err)
					}
					return nil
				}
			}

			// Format not found - build list of available formats
			var availableFormats []string
			for _, f := range options.OutputFormats() {
				availableFormats = append(availableFormats, f.Name())
			}
			if len(availableFormats) == 0 {
				return fmt.Errorf("no output formats registered (use WithOutputFormats to register formats)")
			}
			return fmt.Errorf("unknown format %q (available: %v)", formatName, availableFormats)
		},
		Before: func(ctx context.Context, cmd *v3.Command) (context.Context, error) {
			if cmd.Args().Len() > 0 {
				return ctx, v3.Exit(fmt.Sprintf("unsupported argument: %q", cmd.Args().Get(0)), 3)
			}
			if cmd.Bool("interactive") {
				prefill := map[string]string{}
				if cmd.IsSet("with") {
					prefill["with"] = cmd.String("with")
				}
				if cmd.IsSet("when") {
					prefill["when"] = cmd.String("when")
				}
				if err := protocli.InvokeTUI(ctx, cmd, protocli.StartAtMethod("greeter", "schedule-call"), protocli.WithPrefillFields(prefill)); err != nil {
					return ctx, err
				}
				return ctx, v3.Exit("", 0)
			}
			return ctx, nil
		},
		Flags: flags_schedule_call,
		Name:  "schedule-call",
		Usage: "Book a call in your local timezone",
	})

	// Create ServiceCLI for daemonize command
	serviceCLI := &protocli.ServiceCLI{
		ConfigMessageType: "",
		FactoryOrImpl:     implOrFactory,
		RegisterFunc: func(s *grpc.Server, impl interface{}) {
			RegisterGreeterServiceServer(s, impl.(GreeterServiceServer))
		},
		ServiceName: "greeter",
	}

	// Create daemonize command for starting gRPC server
	daemonCmd := protocli.NewDaemonizeCommand(ctx, []*protocli.ServiceCLI{serviceCLI}, options)

	// Append daemonize command to the list
	commands = append(commands, daemonCmd)

	return commands
}
