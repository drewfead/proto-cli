// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             (unknown)
// source: examples/tui/tui.proto

package tui

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	FarewellService_Farewell_FullMethodName          = "/tui_example.FarewellService/Farewell"
	FarewellService_FarewellMany_FullMethodName      = "/tui_example.FarewellService/FarewellMany"
	FarewellService_ScheduledFarewell_FullMethodName = "/tui_example.FarewellService/ScheduledFarewell"
	FarewellService_LeaveNote_FullMethodName         = "/tui_example.FarewellService/LeaveNote"
	FarewellService_CountdownFarewell_FullMethodName = "/tui_example.FarewellService/CountdownFarewell"
)

// FarewellServiceClient is the client API for FarewellService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// FarewellService demonstrates a second TUI-enabled service.
type FarewellServiceClient interface {
	// Farewell bids goodbye to a person.
	Farewell(ctx context.Context, in *FarewellRequest, opts ...grpc.CallOption) (*FarewellResponse, error)
	// FarewellMany bids goodbye to multiple people.
	FarewellMany(ctx context.Context, in *FarewellManyRequest, opts ...grpc.CallOption) (*FarewellManyResponse, error)
	// ScheduledFarewell schedules a farewell for a future time at an address.
	// Demonstrates WKT (Timestamp) and nested message flattening in the TUI.
	ScheduledFarewell(ctx context.Context, in *ScheduledFarewellRequest, opts ...grpc.CallOption) (*ScheduledFarewellResponse, error)
	// LeaveNote attaches a free-form JSON note to a farewell.
	// Demonstrates the JSON editor TUI control.
	LeaveNote(ctx context.Context, in *NoteRequest, opts ...grpc.CallOption) (*NoteResponse, error)
	// CountdownFarewell streams a dramatic countdown before the final goodbye.
	// Demonstrates server-streaming in the TUI.
	CountdownFarewell(ctx context.Context, in *CountdownFarewellRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CountdownFarewellResponse], error)
}

type farewellServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFarewellServiceClient(cc grpc.ClientConnInterface) FarewellServiceClient {
	return &farewellServiceClient{cc}
}

func (c *farewellServiceClient) Farewell(ctx context.Context, in *FarewellRequest, opts ...grpc.CallOption) (*FarewellResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FarewellResponse)
	err := c.cc.Invoke(ctx, FarewellService_Farewell_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *farewellServiceClient) FarewellMany(ctx context.Context, in *FarewellManyRequest, opts ...grpc.CallOption) (*FarewellManyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FarewellManyResponse)
	err := c.cc.Invoke(ctx, FarewellService_FarewellMany_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *farewellServiceClient) ScheduledFarewell(ctx context.Context, in *ScheduledFarewellRequest, opts ...grpc.CallOption) (*ScheduledFarewellResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScheduledFarewellResponse)
	err := c.cc.Invoke(ctx, FarewellService_ScheduledFarewell_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *farewellServiceClient) LeaveNote(ctx context.Context, in *NoteRequest, opts ...grpc.CallOption) (*NoteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NoteResponse)
	err := c.cc.Invoke(ctx, FarewellService_LeaveNote_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *farewellServiceClient) CountdownFarewell(ctx context.Context, in *CountdownFarewellRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CountdownFarewellResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &FarewellService_ServiceDesc.Streams[0], FarewellService_CountdownFarewell_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[CountdownFarewellRequest, CountdownFarewellResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type FarewellService_CountdownFarewellClient = grpc.ServerStreamingClient[CountdownFarewellResponse]

// FarewellServiceServer is the server API for FarewellService service.
// All implementations must embed UnimplementedFarewellServiceServer
// for forward compatibility.
//
// FarewellService demonstrates a second TUI-enabled service.
type FarewellServiceServer interface {
	// Farewell bids goodbye to a person.
	Farewell(context.Context, *FarewellRequest) (*FarewellResponse, error)
	// FarewellMany bids goodbye to multiple people.
	FarewellMany(context.Context, *FarewellManyRequest) (*FarewellManyResponse, error)
	// ScheduledFarewell schedules a farewell for a future time at an address.
	// Demonstrates WKT (Timestamp) and nested message flattening in the TUI.
	ScheduledFarewell(context.Context, *ScheduledFarewellRequest) (*ScheduledFarewellResponse, error)
	// LeaveNote attaches a free-form JSON note to a farewell.
	// Demonstrates the JSON editor TUI control.
	LeaveNote(context.Context, *NoteRequest) (*NoteResponse, error)
	// CountdownFarewell streams a dramatic countdown before the final goodbye.
	// Demonstrates server-streaming in the TUI.
	CountdownFarewell(*CountdownFarewellRequest, grpc.ServerStreamingServer[CountdownFarewellResponse]) error
	mustEmbedUnimplementedFarewellServiceServer()
}

// UnimplementedFarewellServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFarewellServiceServer struct{}

func (UnimplementedFarewellServiceServer) Farewell(context.Context, *FarewellRequest) (*FarewellResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Farewell not implemented")
}
func (UnimplementedFarewellServiceServer) FarewellMany(context.Context, *FarewellManyRequest) (*FarewellManyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FarewellMany not implemented")
}
func (UnimplementedFarewellServiceServer) ScheduledFarewell(context.Context, *ScheduledFarewellRequest) (*ScheduledFarewellResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ScheduledFarewell not implemented")
}
func (UnimplementedFarewellServiceServer) LeaveNote(context.Context, *NoteRequest) (*NoteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LeaveNote not implemented")
}
func (UnimplementedFarewellServiceServer) CountdownFarewell(*CountdownFarewellRequest, grpc.ServerStreamingServer[CountdownFarewellResponse]) error {
	return status.Error(codes.Unimplemented, "method CountdownFarewell not implemented")
}
func (UnimplementedFarewellServiceServer) mustEmbedUnimplementedFarewellServiceServer() {}
func (UnimplementedFarewellServiceServer) testEmbeddedByValue()                         {}

// UnsafeFarewellServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FarewellServiceServer will
// result in compilation errors.
type UnsafeFarewellServiceServer interface {
	mustEmbedUnimplementedFarewellServiceServer()
}

func RegisterFarewellServiceServer(s grpc.ServiceRegistrar, srv FarewellServiceServer) {
	// If the following call panics, it indicates UnimplementedFarewellServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FarewellService_ServiceDesc, srv)
}

func _FarewellService_Farewell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FarewellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FarewellServiceServer).Farewell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FarewellService_Farewell_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FarewellServiceServer).Farewell(ctx, req.(*FarewellRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FarewellService_FarewellMany_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FarewellManyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FarewellServiceServer).FarewellMany(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FarewellService_FarewellMany_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FarewellServiceServer).FarewellMany(ctx, req.(*FarewellManyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FarewellService_ScheduledFarewell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduledFarewellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FarewellServiceServer).ScheduledFarewell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FarewellService_ScheduledFarewell_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FarewellServiceServer).ScheduledFarewell(ctx, req.(*ScheduledFarewellRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FarewellService_LeaveNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FarewellServiceServer).LeaveNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FarewellService_LeaveNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FarewellServiceServer).LeaveNote(ctx, req.(*NoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FarewellService_CountdownFarewell_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CountdownFarewellRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FarewellServiceServer).CountdownFarewell(m, &grpc.GenericServerStream[CountdownFarewellRequest, CountdownFarewellResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type FarewellService_CountdownFarewellServer = grpc.ServerStreamingServer[CountdownFarewellResponse]

// FarewellService_ServiceDesc is the grpc.ServiceDesc for FarewellService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FarewellService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tui_example.FarewellService",
	HandlerType: (*FarewellServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Farewell",
			Handler:    _FarewellService_Farewell_Handler,
		},
		{
			MethodName: "FarewellMany",
			Handler:    _FarewellService_FarewellMany_Handler,
		},
		{
			MethodName: "ScheduledFarewell",
			Handler:    _FarewellService_ScheduledFarewell_Handler,
		},
		{
			MethodName: "LeaveNote",
			Handler:    _FarewellService_LeaveNote_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CountdownFarewell",
			Handler:       _FarewellService_CountdownFarewell_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "examples/tui/tui.proto",
}

const (
	DirectoryService_ListPeople_FullMethodName = "/tui_example.DirectoryService/ListPeople"
)

// DirectoryServiceClient is the client API for DirectoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// DirectoryService streams a list of contacts you can greet.
// Selecting a contact in the TUI navigates directly to the greeter form
// with the recipient's name pre-populated.
type DirectoryServiceClient interface {
	// ListPeople streams the contact directory, one card per person.
	ListPeople(ctx context.Context, in *ListPeopleRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PersonCard], error)
}

type directoryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDirectoryServiceClient(cc grpc.ClientConnInterface) DirectoryServiceClient {
	return &directoryServiceClient{cc}
}

func (c *directoryServiceClient) ListPeople(ctx context.Context, in *ListPeopleRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PersonCard], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DirectoryService_ServiceDesc.Streams[0], DirectoryService_ListPeople_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ListPeopleRequest, PersonCard]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DirectoryService_ListPeopleClient = grpc.ServerStreamingClient[PersonCard]

// DirectoryServiceServer is the server API for DirectoryService service.
// All implementations must embed UnimplementedDirectoryServiceServer
// for forward compatibility.
//
// DirectoryService streams a list of contacts you can greet.
// Selecting a contact in the TUI navigates directly to the greeter form
// with the recipient's name pre-populated.
type DirectoryServiceServer interface {
	// ListPeople streams the contact directory, one card per person.
	ListPeople(*ListPeopleRequest, grpc.ServerStreamingServer[PersonCard]) error
	mustEmbedUnimplementedDirectoryServiceServer()
}

// UnimplementedDirectoryServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDirectoryServiceServer struct{}

func (UnimplementedDirectoryServiceServer) ListPeople(*ListPeopleRequest, grpc.ServerStreamingServer[PersonCard]) error {
	return status.Error(codes.Unimplemented, "method ListPeople not implemented")
}
func (UnimplementedDirectoryServiceServer) mustEmbedUnimplementedDirectoryServiceServer() {}
func (UnimplementedDirectoryServiceServer) testEmbeddedByValue()                          {}

// UnsafeDirectoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DirectoryServiceServer will
// result in compilation errors.
type UnsafeDirectoryServiceServer interface {
	mustEmbedUnimplementedDirectoryServiceServer()
}

func RegisterDirectoryServiceServer(s grpc.ServiceRegistrar, srv DirectoryServiceServer) {
	// If the following call panics, it indicates UnimplementedDirectoryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DirectoryService_ServiceDesc, srv)
}

func _DirectoryService_ListPeople_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListPeopleRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DirectoryServiceServer).ListPeople(m, &grpc.GenericServerStream[ListPeopleRequest, PersonCard]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DirectoryService_ListPeopleServer = grpc.ServerStreamingServer[PersonCard]

// DirectoryService_ServiceDesc is the grpc.ServiceDesc for DirectoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DirectoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tui_example.DirectoryService",
	HandlerType: (*DirectoryServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListPeople",
			Handler:       _DirectoryService_ListPeople_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "examples/tui/tui.proto",
}

const (
	GreeterService_Greet_FullMethodName         = "/tui_example.GreeterService/Greet"
	GreeterService_ListGreetings_FullMethodName = "/tui_example.GreeterService/ListGreetings"
	GreeterService_HiddenMethod_FullMethodName  = "/tui_example.GreeterService/HiddenMethod"
	GreeterService_ColoredGreet_FullMethodName  = "/tui_example.GreeterService/ColoredGreet"
	GreeterService_ScheduleCall_FullMethodName  = "/tui_example.GreeterService/ScheduleCall"
)

// GreeterServiceClient is the client API for GreeterService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// GreeterService demonstrates TUI-enabled gRPC service methods.
type GreeterServiceClient interface {
	// Greet says hello to a person.
	Greet(ctx context.Context, in *GreetRequest, opts ...grpc.CallOption) (*GreetResponse, error)
	// ListGreetings says hello to multiple people.
	ListGreetings(ctx context.Context, in *ListGreetingsRequest, opts ...grpc.CallOption) (*ListGreetingsResponse, error)
	// HiddenMethod is hidden from the TUI but still accessible via CLI.
	HiddenMethod(ctx context.Context, in *GreetRequest, opts ...grpc.CallOption) (*GreetResponse, error)
	// ColoredGreet says hello with a custom color.
	// Demonstrates registering a custom TUI form control for RgbColor.
	ColoredGreet(ctx context.Context, in *ColoredGreetRequest, opts ...grpc.CallOption) (*ColoredGreetResponse, error)
	// ScheduleCall books a call at a time in the caller's local timezone.
	// Demonstrates WithCustomControlForField overriding WithTimestampControl:
	// the "when" Timestamp field uses a date-time picker with SystemTimezone
	// so the user enters local time that is normalised to UTC on submit.
	ScheduleCall(ctx context.Context, in *ScheduleCallRequest, opts ...grpc.CallOption) (*ScheduleCallResponse, error)
}

type greeterServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGreeterServiceClient(cc grpc.ClientConnInterface) GreeterServiceClient {
	return &greeterServiceClient{cc}
}

func (c *greeterServiceClient) Greet(ctx context.Context, in *GreetRequest, opts ...grpc.CallOption) (*GreetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GreetResponse)
	err := c.cc.Invoke(ctx, GreeterService_Greet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *greeterServiceClient) ListGreetings(ctx context.Context, in *ListGreetingsRequest, opts ...grpc.CallOption) (*ListGreetingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGreetingsResponse)
	err := c.cc.Invoke(ctx, GreeterService_ListGreetings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *greeterServiceClient) HiddenMethod(ctx context.Context, in *GreetRequest, opts ...grpc.CallOption) (*GreetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GreetResponse)
	err := c.cc.Invoke(ctx, GreeterService_HiddenMethod_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *greeterServiceClient) ColoredGreet(ctx context.Context, in *ColoredGreetRequest, opts ...grpc.CallOption) (*ColoredGreetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ColoredGreetResponse)
	err := c.cc.Invoke(ctx, GreeterService_ColoredGreet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *greeterServiceClient) ScheduleCall(ctx context.Context, in *ScheduleCallRequest, opts ...grpc.CallOption) (*ScheduleCallResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScheduleCallResponse)
	err := c.cc.Invoke(ctx, GreeterService_ScheduleCall_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GreeterServiceServer is the server API for GreeterService service.
// All implementations must embed UnimplementedGreeterServiceServer
// for forward compatibility.
//
// GreeterService demonstrates TUI-enabled gRPC service methods.
type GreeterServiceServer interface {
	// Greet says hello to a person.
	Greet(context.Context, *GreetRequest) (*GreetResponse, error)
	// ListGreetings says hello to multiple people.
	ListGreetings(context.Context, *ListGreetingsRequest) (*ListGreetingsResponse, error)
	// HiddenMethod is hidden from the TUI but still accessible via CLI.
	HiddenMethod(context.Context, *GreetRequest) (*GreetResponse, error)
	// ColoredGreet says hello with a custom color.
	// Demonstrates registering a custom TUI form control for RgbColor.
	ColoredGreet(context.Context, *ColoredGreetRequest) (*ColoredGreetResponse, error)
	// ScheduleCall books a call at a time in the caller's local timezone.
	// Demonstrates WithCustomControlForField overriding WithTimestampControl:
	// the "when" Timestamp field uses a date-time picker with SystemTimezone
	// so the user enters local time that is normalised to UTC on submit.
	ScheduleCall(context.Context, *ScheduleCallRequest) (*ScheduleCallResponse, error)
	mustEmbedUnimplementedGreeterServiceServer()
}

// UnimplementedGreeterServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGreeterServiceServer struct{}

func (UnimplementedGreeterServiceServer) Greet(context.Context, *GreetRequest) (*GreetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Greet not implemented")
}
func (UnimplementedGreeterServiceServer) ListGreetings(context.Context, *ListGreetingsRequest) (*ListGreetingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListGreetings not implemented")
}
func (UnimplementedGreeterServiceServer) HiddenMethod(context.Context, *GreetRequest) (*GreetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HiddenMethod not implemented")
}
func (UnimplementedGreeterServiceServer) ColoredGreet(context.Context, *ColoredGreetRequest) (*ColoredGreetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ColoredGreet not implemented")
}
func (UnimplementedGreeterServiceServer) ScheduleCall(context.Context, *ScheduleCallRequest) (*ScheduleCallResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ScheduleCall not implemented")
}
func (UnimplementedGreeterServiceServer) mustEmbedUnimplementedGreeterServiceServer() {}
func (UnimplementedGreeterServiceServer) testEmbeddedByValue()                        {}

// UnsafeGreeterServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GreeterServiceServer will
// result in compilation errors.
type UnsafeGreeterServiceServer interface {
	mustEmbedUnimplementedGreeterServiceServer()
}

func RegisterGreeterServiceServer(s grpc.ServiceRegistrar, srv GreeterServiceServer) {
	// If the following call panics, it indicates UnimplementedGreeterServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GreeterService_ServiceDesc, srv)
}

func _GreeterService_Greet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GreetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GreeterServiceServer).Greet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GreeterService_Greet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GreeterServiceServer).Greet(ctx, req.(*GreetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GreeterService_ListGreetings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGreetingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GreeterServiceServer).ListGreetings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GreeterService_ListGreetings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GreeterServiceServer).ListGreetings(ctx, req.(*ListGreetingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GreeterService_HiddenMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GreetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GreeterServiceServer).HiddenMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GreeterService_HiddenMethod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GreeterServiceServer).HiddenMethod(ctx, req.(*GreetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GreeterService_ColoredGreet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ColoredGreetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GreeterServiceServer).ColoredGreet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GreeterService_ColoredGreet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GreeterServiceServer).ColoredGreet(ctx, req.(*ColoredGreetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GreeterService_ScheduleCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScheduleCallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GreeterServiceServer).ScheduleCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GreeterService_ScheduleCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GreeterServiceServer).ScheduleCall(ctx, req.(*ScheduleCallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GreeterService_ServiceDesc is the grpc.ServiceDesc for GreeterService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GreeterService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tui_example.GreeterService",
	HandlerType: (*GreeterServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Greet",
			Handler:    _GreeterService_Greet_Handler,
		},
		{
			MethodName: "ListGreetings",
			Handler:    _GreeterService_ListGreetings_Handler,
		},
		{
			MethodName: "HiddenMethod",
			Handler:    _GreeterService_HiddenMethod_Handler,
		},
		{
			MethodName: "ColoredGreet",
			Handler:    _GreeterService_ColoredGreet_Handler,
		},
		{
			MethodName: "ScheduleCall",
			Handler:    _GreeterService_ScheduleCall_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "examples/tui/tui.proto",
}
