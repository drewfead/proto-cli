package generate

import (
	"github.com/dave/jennifer/jen"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// GenerateFile generates CLI code for all services in a proto file.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Services) == 0 {
		return
	}

	filename := file.GeneratedFilenamePrefix + "_cli.pb.go"

	// Create one jen file for all services in this proto file
	f := jen.NewFile(string(file.GoPackageName))
	f.HeaderComment("Code generated by protoc-gen-cli. DO NOT EDIT.")
	f.Line()

	// Generate per-service helpers and CLI code
	for _, service := range file.Services {
		// Generate service-prefixed output writer function
		funcName := outputWriterFuncName(service)
		f.Commentf("%s opens the specified output file or returns cmd.Writer (if set) or stdout", funcName)
		f.Func().Id(funcName).Params(
			jen.Id("cmd").Op("*").Qual("github.com/urfave/cli/v3", "Command"),
			jen.Id("path").String(),
		).Params(jen.Qual("io", "Writer"), jen.Error()).Block(
			jen.If(jen.Id("path").Op("==").Lit("-").Op("||").Id("path").Op("==").Lit("")).Block(
				jen.Comment("Use cmd.Writer if set, otherwise try root command's Writer, otherwise stdout"),
				jen.If(jen.Id("cmd").Dot("Writer").Op("!=").Nil()).Block(
					jen.Return(jen.Id("cmd").Dot("Writer"), jen.Nil()),
				),
				jen.If(jen.Id("cmd").Dot("Root").Call().Dot("Writer").Op("!=").Nil()).Block(
					jen.Return(jen.Id("cmd").Dot("Root").Call().Dot("Writer"), jen.Nil()),
				),
				jen.Return(jen.Qual("os", "Stdout"), jen.Nil()),
			),
			jen.Return(jen.Qual("os", "Create").Call(jen.Id("path"))),
		)
		f.Line()

		// Collect enums used by this service
		enumsUsed := make(map[string]*protogen.Enum)
		for _, method := range service.Methods {
			for _, field := range method.Input.Fields {
				if field.Desc.Kind() == protoreflect.EnumKind {
					enumFullName := string(field.Enum.Desc.FullName())
					enumsUsed[enumFullName] = field.Enum
				}
			}
		}
		configOpts := getServiceConfigOptions(service)
		if configOpts != nil && configOpts.ConfigMessage != "" {
			for _, msg := range file.Messages {
				if msg.GoIdent.GoName == configOpts.ConfigMessage {
					for _, field := range msg.Fields {
						if field.Desc.Kind() == protoreflect.EnumKind {
							enumFullName := string(field.Enum.Desc.FullName())
							enumsUsed[enumFullName] = field.Enum
						}
					}
					break
				}
			}
		}

		// Generate service-prefixed enum parsers
		for _, enum := range enumsUsed {
			generateEnumParser(f, service, enum)
		}

		// Generate service-prefixed local stream wrapper types
		for _, method := range service.Methods {
			if method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient() {
				generateLocalStreamWrapper(f, service, method)
			}
		}

		// Generate CLI for this service
		generateServiceCLI(f, file, service)
	}

	// Write the generated code
	content := f.GoString()
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P(content)
}

func generateServiceCLI(f *jen.File, file *protogen.File, service *protogen.Service) {
	// Generate the Command function
	funcName := service.GoName + "Command"

	f.Commentf("%s creates a CLI for %s with options", funcName, service.GoName)
	f.Commentf("The implOrFactory parameter can be either a direct service implementation or a factory function")
	f.Func().Id(funcName).Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("implOrFactory").Interface(),
		jen.Id("opts").Op("...").Qual("github.com/drewfead/proto-cli", "ServiceOption"),
	).Op("*").Qual("github.com/drewfead/proto-cli", "ServiceCLI").Block(
		generateServiceCommands(file, service)...,
	)
	f.Line()

	// Generate the Flat Command function for single-service CLIs
	funcNameFlat := service.GoName + "CommandsFlat"

	f.Commentf("%s creates a flat command structure for %s (for single-service CLIs)", funcNameFlat, service.GoName)
	f.Commentf("This returns RPC commands directly at the root level instead of nested under a service command.")
	f.Commentf("The implOrFactory parameter can be either a direct service implementation or a factory function")
	f.Commentf("The returned slice includes all RPC commands plus a daemonize command for starting a gRPC server.")
	f.Func().Id(funcNameFlat).Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("implOrFactory").Interface(),
		jen.Id("opts").Op("...").Qual("github.com/drewfead/proto-cli", "ServiceOption"),
	).Index().Op("*").Qual("github.com/urfave/cli/v3", "Command").Block(
		generateServiceCommandsFlat(file, service)...,
	)
	f.Line()
}

func generateServiceCommands(file *protogen.File, service *protogen.Service) []jen.Code {
	var statements []jen.Code

	// Check for service config annotation
	configOpts := getServiceConfigOptions(service)
	var configMessageType string
	if configOpts != nil && configOpts.ConfigMessage != "" {
		configMessageType = configOpts.ConfigMessage
	}

	// Apply service options
	statements = append(statements,
		jen.Id("options").Op(":=").Qual("github.com/drewfead/proto-cli", "ApplyServiceOptions").Call(jen.Id("opts").Op("...")),
		jen.Line(),
	)

	// Determine default format
	statements = append(statements,
		jen.Comment("Determine default format (first registered format, or empty if none)"),
		jen.Var().Id("defaultFormat").String(),
		jen.If(jen.Len(jen.Id("options").Dot("OutputFormats").Call()).Op(">").Lit(0)).Block(
			jen.Id("defaultFormat").Op("=").Id("options").Dot("OutputFormats").Call().Index(jen.Lit(0)).Dot("Name").Call(),
		),
		jen.Line(),
	)

	// Create commands slice
	statements = append(statements,
		jen.Var().Id("commands").Index().Op("*").Qual("github.com/urfave/cli/v3", "Command"),
		jen.Line(),
	)

	// Collect local-only method paths for server-side enforcement
	var localOnlyMethods []string

	// Generate command for each method
	for _, method := range service.Methods {
		isClientStreaming := method.Desc.IsStreamingClient()
		isServerStreaming := method.Desc.IsStreamingServer()

		if isClientStreaming {
			// Skip client streaming and bidi for Phase 1
			continue
		}

		// Check if method is local-only
		if cmdOpts := getMethodCommandOptions(method); cmdOpts != nil && cmdOpts.GetLocalOnly() {
			fullPath := "/" + string(service.Desc.FullName()) + "/" + string(method.Desc.Name())
			localOnlyMethods = append(localOnlyMethods, fullPath)
		}

		if isServerStreaming {
			// Generate server streaming command
			statements = append(statements, generateServerStreamingCommand(service, method, configMessageType, file)...)
		} else {
			// Generate unary command (existing logic)
			statements = append(statements, generateMethodCommand(service, method, configMessageType, file)...)
		}
	}

	// Get service name and help fields from annotation or use defaults
	serviceName := toKebabCase(service.GoName)
	serviceDescription := stripServiceSuffix(service.GoName) + " commands" // Short description
	var serviceLongDescription, serviceUsageText, serviceArgsUsage string  // Long description, custom usage, args

	serviceOpts := getServiceOptions(service)
	if serviceOpts != nil {
		if serviceOpts.Name != "" {
			serviceName = serviceOpts.Name
		}
		if serviceOpts.Description != "" {
			serviceDescription = serviceOpts.Description
		}
		if serviceOpts.LongDescription != "" {
			serviceLongDescription = serviceOpts.LongDescription
		}
		if serviceOpts.UsageText != "" {
			serviceUsageText = serviceOpts.UsageText
		}
		if serviceOpts.ArgsUsage != "" {
			serviceArgsUsage = serviceOpts.ArgsUsage
		}
	}

	// Fallback to proto source comment if no annotation provided a description
	defaultDescription := stripServiceSuffix(service.GoName) + " commands"
	if serviceDescription == defaultDescription {
		if comment := cleanProtoComment(service.Comments.Leading); comment != "" {
			serviceDescription = firstLine(comment)
		}
	}

	registerFunc := "Register" + service.GoName + "Server"

	// Build service command dict with help fields
	serviceCommandDict := jen.Dict{
		jen.Id("Name"):     jen.Lit(serviceName),
		jen.Id("Usage"):    jen.Lit(serviceDescription),
		jen.Id("Commands"): jen.Id("commands"),
	}

	// For TUI-enabled services, add --interactive flag and a Before hook that
	// deep-links into the TUI at this service's method list.
	tuiEnabled := serviceOpts != nil && serviceOpts.GetTui() != nil
	if tuiEnabled {
		serviceCommandDict[jen.Id("Flags")] = jen.Index().Qual("github.com/urfave/cli/v3", "Flag").Values(
			jen.Op("&").Qual("github.com/urfave/cli/v3", "BoolFlag").Values(jen.Dict{
				jen.Id("Name"):  jen.Lit("interactive"),
				jen.Id("Usage"): jen.Lit("Open the interactive TUI at this service"),
			}),
		)
		serviceCommandDict[jen.Id("Before")] = jen.Func().Params(
			jen.Id("ctx").Qual("context", "Context"),
			jen.Id("cmd").Op("*").Qual("github.com/urfave/cli/v3", "Command"),
		).Params(jen.Qual("context", "Context"), jen.Error()).Block(
			jen.If(
				jen.Id("cmd").Dot("Args").Call().Dot("Len").Call().Op(">").Lit(0),
			).Block(
				jen.Return(
				jen.Id("ctx"),
				jen.Qual("github.com/urfave/cli/v3", "Exit").Call(
					jen.Qual("fmt", "Sprintf").Call(
						jen.Lit("unsupported argument: %q"),
						jen.Id("cmd").Dot("Args").Call().Dot("Get").Call(jen.Lit(0)),
					),
					jen.Lit(3),
				),
			),
			),
			jen.If(jen.Id("cmd").Dot("Bool").Call(jen.Lit("interactive"))).Block(
				jen.If(
					jen.Err().Op(":=").Qual("github.com/drewfead/proto-cli", "InvokeTUI").Call(
						jen.Id("ctx"),
						jen.Id("cmd"),
						jen.Qual("github.com/drewfead/proto-cli", "StartAtService").Call(jen.Lit(serviceName)),
					),
					jen.Err().Op("!=").Nil(),
				).Block(jen.Return(jen.Id("ctx"), jen.Err())),
				jen.Return(jen.Id("ctx"), jen.Qual("github.com/urfave/cli/v3", "Exit").Call(jen.Lit(""), jen.Lit(0))),
			),
			jen.Return(jen.Id("ctx"), jen.Nil()),
		)
	}

	// Add optional help fields to service command if provided
	if serviceLongDescription != "" {
		serviceCommandDict[jen.Id("Description")] = jen.Lit(serviceLongDescription)
	}
	if serviceUsageText != "" {
		serviceCommandDict[jen.Id("UsageText")] = jen.Lit(serviceUsageText)
	}
	if serviceArgsUsage != "" {
		serviceCommandDict[jen.Id("ArgsUsage")] = jen.Lit(serviceArgsUsage)
	}

	// Build the ServiceCLI dict
	serviceCLIDict := jen.Dict{
		jen.Id("Command"):           jen.Op("&").Qual("github.com/urfave/cli/v3", "Command").Values(serviceCommandDict),
		jen.Id("ServiceName"):       jen.Lit(serviceName),
		jen.Id("ConfigMessageType"): jen.Lit(configMessageType),
		jen.Id("FactoryOrImpl"):     jen.Id("implOrFactory"),
		jen.Id("RegisterFunc"): jen.Func().Params(
			jen.Id("s").Op("*").Qual("google.golang.org/grpc", "Server"),
			jen.Id("impl").Interface(),
		).Block(
			jen.Id(registerFunc).Call(
				jen.Id("s"),
				jen.Id("impl").Assert(jen.Id(service.GoName+"Server")),
			),
		),
	}

	// Add ConfigPrototype if there's a config message
	if configMessageType != "" {
		serviceCLIDict[jen.Id("ConfigPrototype")] = jen.Op("&").Id(configMessageType).Values()
	}

	// Add LocalOnlyMethods if any methods are marked local-only
	if len(localOnlyMethods) > 0 {
		methodLiterals := make([]jen.Code, len(localOnlyMethods))
		for i, m := range localOnlyMethods {
			methodLiterals[i] = jen.Lit(m)
		}
		serviceCLIDict[jen.Id("LocalOnlyMethods")] = jen.Index().String().Values(methodLiterals...)
	}

	// Add TUIDescriptor if service has tui=true annotation
	if tuiDesc := generateTUIDescriptor(file, service); tuiDesc != nil {
		serviceCLIDict[jen.Id("TUIDescriptor")] = tuiDesc
	}

	statements = append(statements,
		jen.Line(),
		jen.Return(jen.Op("&").Qual("github.com/drewfead/proto-cli", "ServiceCLI").Values(serviceCLIDict)),
	)

	return statements
}

func generateServiceCommandsFlat(file *protogen.File, service *protogen.Service) []jen.Code {
	var statements []jen.Code

	// Check for service config annotation
	configOpts := getServiceConfigOptions(service)
	var configMessageType string
	if configOpts != nil && configOpts.ConfigMessage != "" {
		configMessageType = configOpts.ConfigMessage
	}

	// Apply service options
	statements = append(statements,
		jen.Id("options").Op(":=").Qual("github.com/drewfead/proto-cli", "ApplyServiceOptions").Call(jen.Id("opts").Op("...")),
		jen.Line(),
	)

	// Determine default format
	statements = append(statements,
		jen.Comment("Determine default format (first registered format, or empty if none)"),
		jen.Var().Id("defaultFormat").String(),
		jen.If(jen.Len(jen.Id("options").Dot("OutputFormats").Call()).Op(">").Lit(0)).Block(
			jen.Id("defaultFormat").Op("=").Id("options").Dot("OutputFormats").Call().Index(jen.Lit(0)).Dot("Name").Call(),
		),
		jen.Line(),
	)

	// Create commands slice
	statements = append(statements,
		jen.Var().Id("commands").Index().Op("*").Qual("github.com/urfave/cli/v3", "Command"),
		jen.Line(),
	)

	// Collect local-only method paths for server-side enforcement
	var localOnlyMethods []string

	// Generate command for each method
	for _, method := range service.Methods {
		isClientStreaming := method.Desc.IsStreamingClient()
		isServerStreaming := method.Desc.IsStreamingServer()

		if isClientStreaming {
			// Skip client streaming and bidi for Phase 1
			continue
		}

		// Check if method is local-only
		if cmdOpts := getMethodCommandOptions(method); cmdOpts != nil && cmdOpts.GetLocalOnly() {
			fullPath := "/" + string(service.Desc.FullName()) + "/" + string(method.Desc.Name())
			localOnlyMethods = append(localOnlyMethods, fullPath)
		}

		if isServerStreaming {
			// Generate server streaming command
			statements = append(statements, generateServerStreamingCommand(service, method, configMessageType, file)...)
		} else {
			// Generate unary command (existing logic)
			statements = append(statements, generateMethodCommand(service, method, configMessageType, file)...)
		}
	}

	// Get service name and register func
	serviceName := toKebabCase(service.GoName)
	serviceOpts := getServiceOptions(service)
	if serviceOpts != nil && serviceOpts.Name != "" {
		serviceName = serviceOpts.Name
	}

	registerFunc := "Register" + service.GoName + "Server"

	// Create service CLI for daemonize command
	serviceCLIDict := jen.Dict{
		jen.Id("ServiceName"):       jen.Lit(serviceName),
		jen.Id("ConfigMessageType"): jen.Lit(configMessageType),
		jen.Id("FactoryOrImpl"):     jen.Id("implOrFactory"),
		jen.Id("RegisterFunc"): jen.Func().Params(
			jen.Id("s").Op("*").Qual("google.golang.org/grpc", "Server"),
			jen.Id("impl").Interface(),
		).Block(
			jen.Id(registerFunc).Call(
				jen.Id("s"),
				jen.Id("impl").Assert(jen.Id(service.GoName+"Server")),
			),
		),
	}

	// Add ConfigPrototype if there's a config message
	if configMessageType != "" {
		serviceCLIDict[jen.Id("ConfigPrototype")] = jen.Op("&").Id(configMessageType).Values()
	}

	// Add LocalOnlyMethods if any methods are marked local-only
	if len(localOnlyMethods) > 0 {
		methodLiterals := make([]jen.Code, len(localOnlyMethods))
		for i, m := range localOnlyMethods {
			methodLiterals[i] = jen.Lit(m)
		}
		serviceCLIDict[jen.Id("LocalOnlyMethods")] = jen.Index().String().Values(methodLiterals...)
	}

	statements = append(statements,
		jen.Line(),
		jen.Comment("Create ServiceCLI for daemonize command"),
		jen.Id("serviceCLI").Op(":=").Op("&").Qual("github.com/drewfead/proto-cli", "ServiceCLI").Values(serviceCLIDict),
		jen.Line(),
	)

	// Create daemonize command
	statements = append(statements,
		jen.Comment("Create daemonize command for starting gRPC server"),
		jen.Id("daemonCmd").Op(":=").Qual("github.com/drewfead/proto-cli", "NewDaemonizeCommand").Call(
			jen.Id("ctx"),
			jen.Index().Op("*").Qual("github.com/drewfead/proto-cli", "ServiceCLI").Values(jen.Id("serviceCLI")),
			jen.Id("options"),
		),
		jen.Line(),
	)

	// Append daemonize to commands
	statements = append(statements,
		jen.Comment("Append daemonize command to the list"),
		jen.Id("commands").Op("=").Append(jen.Id("commands"), jen.Id("daemonCmd")),
		jen.Line(),
	)

	// Return commands slice
	statements = append(statements,
		jen.Return(jen.Id("commands")),
	)

	return statements
}
