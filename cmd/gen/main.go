package main

import (
	"fmt"
	"os"
	"strings"
	"unicode"

	"github.com/dave/jennifer/jen"
	"github.com/drewfead/proto-cli/internal/clipb"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Services) == 0 {
		return
	}

	filename := file.GeneratedFilenamePrefix + "_cli.pb.go"

	// Create one jen file for all services in this proto file
	f := jen.NewFile(string(file.GoPackageName))
	f.HeaderComment("Code generated by protoc-gen-cli. DO NOT EDIT.")
	f.Line()

	// Generate helper function for output writer (only once per file)
	f.Comment("getOutputWriter opens the specified output file or returns stdout")
	f.Func().Id("getOutputWriter").Params(
		jen.Id("path").String(),
	).Params(jen.Qual("io", "Writer"), jen.Error()).Block(
		jen.If(jen.Id("path").Op("==").Lit("-").Op("||").Id("path").Op("==").Lit("")).Block(
			jen.Return(jen.Qual("os", "Stdout"), jen.Nil()),
		),
		jen.Return(jen.Qual("os", "Create").Call(jen.Id("path"))),
	)
	f.Line()

	// Generate local stream wrapper types for streaming methods (once per file)
	for _, service := range file.Services {
		for _, method := range service.Methods {
			if method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient() {
				generateLocalStreamWrapper(f, method)
			}
		}
	}

	// Generate CLI for each service
	for _, service := range file.Services {
		generateServiceCLI(f, file, service)
	}

	// Write the generated code
	content := f.GoString()
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P(content)
}

// getServiceConfigOptions extracts the service_config extension from service options.
func getServiceConfigOptions(service *protogen.Service) *clipb.ServiceConfigOptions {
	opts := service.Desc.Options()
	if opts == nil {
		return nil
	}

	if !proto.HasExtension(opts, clipb.E_ServiceConfig) {
		return nil
	}

	ext := proto.GetExtension(opts, clipb.E_ServiceConfig)
	if ext == nil {
		return nil
	}

	configOpts, ok := ext.(*clipb.ServiceConfigOptions)
	if !ok {
		return nil
	}

	return configOpts
}

// qualifyType returns a jen.Code that properly references a Go type
// If the type is in the same package as the file being generated, use jen.Id()
// Otherwise, use jen.Qual() to import from the correct package.
func qualifyType(file *protogen.File, message *protogen.Message, pointer bool) *jen.Statement {
	var stmt *jen.Statement

	// Check if the message is in the same package as the file being generated
	if message.GoIdent.GoImportPath == file.GoImportPath {
		// Same package - use simple identifier
		stmt = jen.Id(message.GoIdent.GoName)
	} else {
		// Different package - use qualified import
		stmt = jen.Qual(string(message.GoIdent.GoImportPath), message.GoIdent.GoName)
	}

	if pointer {
		return jen.Op("*").Add(stmt)
	}
	return stmt
}

// toKebabCase converts Go field names to kebab-case for CLI flags.
// Examples: StartTime -> start-time, CalendarID -> calendar-id.
func toKebabCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && unicode.IsUpper(r) {
			result.WriteRune('-')
		}
		result.WriteRune(unicode.ToLower(r))
	}
	return result.String()
}

// stripServiceSuffix removes "Service" suffix from service names to avoid redundancy.
// Examples: UserService -> User, StreamingService -> Streaming, Admin -> Admin.
func stripServiceSuffix(s string) string {
	return strings.TrimSuffix(s, "Service")
}

// getServiceOptions extracts (cli.service) annotation from a service.
func getServiceOptions(service *protogen.Service) *clipb.ServiceOptions {
	opts := service.Desc.Options()
	if opts == nil {
		return nil
	}

	ext := proto.GetExtension(opts, clipb.E_Service)
	if ext == nil {
		return nil
	}

	serviceOpts, ok := ext.(*clipb.ServiceOptions)
	if !ok {
		return nil
	}

	return serviceOpts
}

// getMethodCommandOptions extracts (cli.command) annotation from a method.
func getMethodCommandOptions(method *protogen.Method) *clipb.CommandOptions {
	opts := method.Desc.Options()
	if opts == nil {
		return nil
	}

	ext := proto.GetExtension(opts, clipb.E_Command)
	if ext == nil {
		return nil
	}

	cmdOpts, ok := ext.(*clipb.CommandOptions)
	if !ok {
		return nil
	}

	return cmdOpts
}

func generateServiceCLI(f *jen.File, file *protogen.File, service *protogen.Service) {
	// Generate the Command function
	funcName := service.GoName + "Command"

	f.Commentf("%s creates a CLI for %s with options", funcName, service.GoName)
	f.Commentf("The implOrFactory parameter can be either a direct service implementation or a factory function")
	f.Func().Id(funcName).Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("implOrFactory").Interface(),
		jen.Id("opts").Op("...").Qual("github.com/drewfead/proto-cli", "ServiceOption"),
	).Op("*").Qual("github.com/drewfead/proto-cli", "ServiceCLI").Block(
		generateServiceCommands(file, service)...,
	)
	f.Line()
}

func generateServiceCommands(file *protogen.File, service *protogen.Service) []jen.Code {
	var statements []jen.Code

	// Check for service config annotation
	configOpts := getServiceConfigOptions(service)
	var configMessageType string
	if configOpts != nil && configOpts.ConfigMessage != "" {
		configMessageType = configOpts.ConfigMessage
	}

	// Apply service options
	statements = append(statements,
		jen.Id("options").Op(":=").Qual("github.com/drewfead/proto-cli", "ApplyServiceOptions").Call(jen.Id("opts").Op("...")),
		jen.Line(),
	)

	// Determine default format
	statements = append(statements,
		jen.Comment("Determine default format (first registered format, or empty if none)"),
		jen.Var().Id("defaultFormat").String(),
		jen.If(jen.Len(jen.Id("options").Dot("OutputFormats").Call()).Op(">").Lit(0)).Block(
			jen.Id("defaultFormat").Op("=").Id("options").Dot("OutputFormats").Call().Index(jen.Lit(0)).Dot("Name").Call(),
		),
		jen.Line(),
	)

	// Create commands slice
	statements = append(statements,
		jen.Var().Id("commands").Index().Op("*").Qual("github.com/urfave/cli/v3", "Command"),
		jen.Line(),
	)

	// Generate command for each method
	for _, method := range service.Methods {
		isClientStreaming := method.Desc.IsStreamingClient()
		isServerStreaming := method.Desc.IsStreamingServer()

		if isClientStreaming {
			// Skip client streaming and bidi for Phase 1
			continue
		}

		if isServerStreaming {
			// Generate server streaming command
			statements = append(statements, generateServerStreamingCommand(service, method, configMessageType, file)...)
		} else {
			// Generate unary command (existing logic)
			statements = append(statements, generateMethodCommand(service, method, configMessageType, file)...)
		}
	}

	// Get service name from annotation or use kebab-case default
	serviceName := toKebabCase(service.GoName)
	serviceOpts := getServiceOptions(service)
	if serviceOpts != nil && serviceOpts.Name != "" {
		serviceName = serviceOpts.Name
	}

	// Get service description from annotation or use default
	serviceDescription := stripServiceSuffix(service.GoName) + " commands"
	if serviceOpts != nil && serviceOpts.Description != "" {
		serviceDescription = serviceOpts.Description
	}

	registerFunc := "Register" + service.GoName + "Server"

	// Build the ServiceCLI dict
	serviceCLIDict := jen.Dict{
		jen.Id("Command"): jen.Op("&").Qual("github.com/urfave/cli/v3", "Command").Values(jen.Dict{
			jen.Id("Name"):     jen.Lit(serviceName),
			jen.Id("Usage"):    jen.Lit(serviceDescription),
			jen.Id("Commands"): jen.Id("commands"),
		}),
		jen.Id("ServiceName"):       jen.Lit(serviceName),
		jen.Id("ConfigMessageType"): jen.Lit(configMessageType),
		jen.Id("FactoryOrImpl"):     jen.Id("implOrFactory"),
		jen.Id("RegisterFunc"): jen.Func().Params(
			jen.Id("s").Op("*").Qual("google.golang.org/grpc", "Server"),
			jen.Id("impl").Interface(),
		).Block(
			jen.Id(registerFunc).Call(
				jen.Id("s"),
				jen.Id("impl").Assert(jen.Id(service.GoName+"Server")),
			),
		),
	}

	// Add ConfigPrototype if there's a config message
	if configMessageType != "" {
		serviceCLIDict[jen.Id("ConfigPrototype")] = jen.Op("&").Id(configMessageType).Values()
	}

	statements = append(statements,
		jen.Line(),
		jen.Return(jen.Op("&").Qual("github.com/drewfead/proto-cli", "ServiceCLI").Values(serviceCLIDict)),
	)

	return statements
}

func generateMethodCommand(service *protogen.Service, method *protogen.Method, configMessageType string, file *protogen.File) []jen.Code {
	var statements []jen.Code

	// Get command name from annotation or use kebab-case default
	cmdName := toKebabCase(method.GoName)
	cmdUsage := method.GoName

	cmdOpts := getMethodCommandOptions(method)
	if cmdOpts != nil {
		// Use custom command name if provided
		if cmdOpts.Name != "" {
			cmdName = cmdOpts.Name
		}
		// Use description if provided
		if cmdOpts.Description != "" {
			cmdUsage = cmdOpts.Description
		}
	}

	// Create a safe variable name (replace hyphens with underscores)
	cmdVarName := strings.ReplaceAll(cmdName, "-", "_")

	// Build flags dynamically with output format support
	statements = append(statements,
		jen.Comment("Build flags for "+cmdName),
		jen.Id("flags_"+cmdVarName).Op(":=").Index().Qual("github.com/urfave/cli/v3", "Flag").Values(
			jen.Op("&").Qual("github.com/urfave/cli/v3", "StringFlag").Values(jen.Dict{
				jen.Id("Name"):  jen.Lit("remote"),
				jen.Id("Usage"): jen.Lit("Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call"),
			}),
			jen.Op("&").Qual("github.com/urfave/cli/v3", "StringFlag").Values(jen.Dict{
				jen.Id("Name"):  jen.Lit("format"),
				jen.Id("Value"): jen.Id("defaultFormat"),
				jen.Id("Usage"): jen.Lit("Output format (use --format to see available formats)"),
			}),
			jen.Op("&").Qual("github.com/urfave/cli/v3", "StringFlag").Values(jen.Dict{
				jen.Id("Name"):  jen.Lit("output"),
				jen.Id("Value"): jen.Lit("-"),
				jen.Id("Usage"): jen.Lit("Output file (- for stdout)"),
			}),
		),
		jen.Line(),
	)

	// Add request field flags
	for _, field := range method.Input.Fields {
		flagCode := generateFlag(field)
		if flagCode != nil {
			statements = append(statements,
				jen.Id("flags_"+cmdVarName).Op("=").Append(jen.Id("flags_"+cmdVarName), flagCode),
			)
		}
	}

	// Add config field flags if service has config
	statements = append(statements, generateConfigFlags(file, configMessageType, cmdVarName)...)

	// Add format-specific flags from registered formats
	statements = append(statements,
		jen.Line(),
		jen.Comment("Add format-specific flags from registered formats"),
		jen.For(
			jen.List(jen.Id("_"), jen.Id("outputFmt")).Op(":=").Range().Id("options").Dot("OutputFormats").Call(),
		).Block(
			jen.Comment("Check if format implements FlagConfiguredOutputFormat"),
			jen.If(
				jen.List(jen.Id("flagConfigured"), jen.Id("ok")).Op(":=").Id("outputFmt").Assert(
					jen.Qual("github.com/drewfead/proto-cli", "FlagConfiguredOutputFormat"),
				),
				jen.Id("ok"),
			).Block(
				jen.Id("flags_"+cmdVarName).Op("=").Append(
					jen.Id("flags_"+cmdVarName),
					jen.Id("flagConfigured").Dot("Flags").Call().Op("..."),
				),
			),
		),
		jen.Line(),
	)

	// Generate the command with lifecycle hooks
	statements = append(statements,
		jen.Id("commands").Op("=").Append(
			jen.Id("commands"),
			jen.Op("&").Qual("github.com/urfave/cli/v3", "Command").Values(jen.Dict{
				jen.Id("Name"):  jen.Lit(cmdName),
				jen.Id("Usage"): jen.Lit(cmdUsage),
				jen.Id("Flags"): jen.Id("flags_" + cmdVarName),
				jen.Id("Action"): jen.Func().Params(
					jen.Id("cmdCtx").Qual("context", "Context"),
					jen.Id("cmd").Op("*").Qual("github.com/urfave/cli/v3", "Command"),
				).Error().Block(
					generateActionBodyWithHooks(file, service, method, configMessageType)...,
				),
			}),
		),
		jen.Line(),
	)

	return statements
}

func generateFlag(field *protogen.Field) jen.Code {
	flagName := toKebabCase(field.GoName)
	usage := field.GoName
	var shorthand string

	// Check for flag annotation
	flagOpts := getFieldFlagOptions(field)
	if flagOpts != nil {
		if flagOpts.Name != "" {
			flagName = flagOpts.Name
		}
		if flagOpts.Usage != "" {
			usage = flagOpts.Usage
		}
		if flagOpts.Shorthand != "" {
			shorthand = flagOpts.Shorthand
		}
	}

	// Helper function to build flag dict with optional Aliases
	buildFlagDict := func() jen.Dict {
		dict := jen.Dict{
			jen.Id("Name"):  jen.Lit(flagName),
			jen.Id("Usage"): jen.Lit(usage),
		}
		if shorthand != "" {
			dict[jen.Id("Aliases")] = jen.Index().String().Values(jen.Lit(shorthand))
		}
		return dict
	}

	switch field.Desc.Kind() {
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return jen.Op("&").Qual("github.com/urfave/cli/v3", "Int32Flag").Values(buildFlagDict())
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return jen.Op("&").Qual("github.com/urfave/cli/v3", "Int64Flag").Values(buildFlagDict())
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return jen.Op("&").Qual("github.com/urfave/cli/v3", "Uint32Flag").Values(buildFlagDict())
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return jen.Op("&").Qual("github.com/urfave/cli/v3", "Uint64Flag").Values(buildFlagDict())
	case protoreflect.FloatKind:
		return jen.Op("&").Qual("github.com/urfave/cli/v3", "Float32Flag").Values(buildFlagDict())
	case protoreflect.DoubleKind:
		return jen.Op("&").Qual("github.com/urfave/cli/v3", "Float64Flag").Values(buildFlagDict())
	case protoreflect.StringKind:
		return jen.Op("&").Qual("github.com/urfave/cli/v3", "StringFlag").Values(buildFlagDict())
	case protoreflect.BoolKind:
		return jen.Op("&").Qual("github.com/urfave/cli/v3", "BoolFlag").Values(buildFlagDict())
	case protoreflect.BytesKind:
		// Represent bytes as string flag, user will need to decode
		return jen.Op("&").Qual("github.com/urfave/cli/v3", "StringFlag").Values(buildFlagDict())
	case protoreflect.EnumKind:
		// Enums are represented as int32 in Go
		return jen.Op("&").Qual("github.com/urfave/cli/v3", "Int32Flag").Values(buildFlagDict())
	case protoreflect.MessageKind:
		// For message fields (e.g., google.protobuf.Timestamp, nested messages),
		// generate a StringFlag that custom deserializers can parse
		messageType := field.Message
		fullyQualifiedName := string(messageType.Desc.FullName())

		// Override usage for message types if not already customized
		if flagOpts == nil || flagOpts.Usage == "" {
			usage = fmt.Sprintf("%s (%s)", field.GoName, fullyQualifiedName)
		}

		dict := jen.Dict{
			jen.Id("Name"):  jen.Lit(flagName),
			jen.Id("Usage"): jen.Lit(usage),
		}
		if shorthand != "" {
			dict[jen.Id("Aliases")] = jen.Index().String().Values(jen.Lit(shorthand))
		}
		return jen.Op("&").Qual("github.com/urfave/cli/v3", "StringFlag").Values(dict)
	case protoreflect.GroupKind:
		// GroupKind is deprecated in proto3 and not supported
		fmt.Fprintf(os.Stderr, "WARNING: Field %s uses deprecated GroupKind and will not generate a CLI flag\n", field.Desc.FullName())
		return nil
	default:
		return nil
	}
}

// generateConfigFlags generates CLI flags for config message fields.
// cmdVarName is the sanitized command name for use in variable names (with hyphens replaced by underscores).
func generateConfigFlags(file *protogen.File, configMessageType string, cmdVarName string) []jen.Code {
	var statements []jen.Code

	if configMessageType == "" {
		return statements
	}

	// Find the config message in the file's messages
	var configMessage *protogen.Message
	for _, msg := range file.Messages {
		if msg.GoIdent.GoName == configMessageType {
			configMessage = msg
			break
		}
	}

	if configMessage == nil {
		return statements
	}

	statements = append(statements,
		jen.Line(),
		jen.Comment("Add config field flags for single-command mode"),
	)

	// Generate flags for each config field
	for _, field := range configMessage.Fields {
		// Get the cli.flag annotation if present
		flagOpts := getFieldFlagOptions(field)
		if flagOpts == nil {
			// No flag annotation, skip this field
			continue
		}

		flagName := flagOpts.Name
		if flagName == "" {
			flagName = toKebabCase(field.GoName)
		}

		usage := flagOpts.Usage
		if usage == "" {
			usage = field.GoName
		}

		shorthand := flagOpts.Shorthand

		// Helper to build flag dict with optional Aliases
		buildFlagDict := func() jen.Dict {
			dict := jen.Dict{
				jen.Id("Name"):  jen.Lit(flagName),
				jen.Id("Usage"): jen.Lit(usage),
			}
			if shorthand != "" {
				dict[jen.Id("Aliases")] = jen.Index().String().Values(jen.Lit(shorthand))
			}
			return dict
		}

		// Generate flag based on field type
		var flagCode jen.Code
		switch field.Desc.Kind() {
		case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
			flagCode = jen.Op("&").Qual("github.com/urfave/cli/v3", "Int32Flag").Values(buildFlagDict())
		case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
			flagCode = jen.Op("&").Qual("github.com/urfave/cli/v3", "Int64Flag").Values(buildFlagDict())
		case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
			flagCode = jen.Op("&").Qual("github.com/urfave/cli/v3", "Uint32Flag").Values(buildFlagDict())
		case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
			flagCode = jen.Op("&").Qual("github.com/urfave/cli/v3", "Uint64Flag").Values(buildFlagDict())
		case protoreflect.FloatKind:
			flagCode = jen.Op("&").Qual("github.com/urfave/cli/v3", "Float32Flag").Values(buildFlagDict())
		case protoreflect.DoubleKind:
			flagCode = jen.Op("&").Qual("github.com/urfave/cli/v3", "Float64Flag").Values(buildFlagDict())
		case protoreflect.StringKind:
			flagCode = jen.Op("&").Qual("github.com/urfave/cli/v3", "StringFlag").Values(buildFlagDict())
		case protoreflect.BoolKind:
			flagCode = jen.Op("&").Qual("github.com/urfave/cli/v3", "BoolFlag").Values(buildFlagDict())
		case protoreflect.BytesKind:
			flagCode = jen.Op("&").Qual("github.com/urfave/cli/v3", "StringFlag").Values(buildFlagDict())
		case protoreflect.EnumKind:
			flagCode = jen.Op("&").Qual("github.com/urfave/cli/v3", "Int32Flag").Values(buildFlagDict())
		case protoreflect.MessageKind:
			// MessageKind requires custom deserializers, skip auto-generation
			continue
		case protoreflect.GroupKind:
			// GroupKind is deprecated in proto3 and not supported
			fmt.Fprintf(os.Stderr, "WARNING: Field %s uses deprecated GroupKind and will not generate a CLI flag\n", field.Desc.FullName())
			continue
		}

		if flagCode != nil {
			statements = append(statements,
				jen.Id("flags_"+cmdVarName).Op("=").Append(jen.Id("flags_"+cmdVarName), flagCode),
			)
		}
	}

	return statements
}

// getFieldFlagOptions extracts the (cli.flag) annotation from a field
func getFieldFlagOptions(field *protogen.Field) *clipb.FlagOptions {
	opts := field.Desc.Options()
	if opts == nil {
		return nil
	}

	if !proto.HasExtension(opts, clipb.E_Flag) {
		return nil
	}

	ext := proto.GetExtension(opts, clipb.E_Flag)
	if ext == nil {
		return nil
	}

	flagOpts, ok := ext.(*clipb.FlagOptions)
	if !ok {
		return nil
	}

	return flagOpts
}

// generateRequestFieldAssignments generates code to assign flag values to request fields
// Handles both primitive types and nested messages (checking for custom deserializers)
//
//nolint:gocyclo,dupl,maintidx // Complexity comes from handling all proto kinds with optional field support
func generateRequestFieldAssignments(file *protogen.File, method *protogen.Method) []jen.Code {
	var statements []jen.Code

	for _, field := range method.Input.Fields {
		flagName := toKebabCase(field.GoName)

		switch field.Desc.Kind() {
		case protoreflect.MessageKind:
			// For message fields, check if there's a custom deserializer
			// Use fully qualified proto name
			messageType := field.Message
			fullyQualifiedName := string(messageType.Desc.FullName())
			goTypeName := messageType.GoIdent.GoName
			qualifiedType := qualifyType(file, messageType, true)

			statements = append(statements,
				jen.Comment(fmt.Sprintf("Field %s: check for custom deserializer for %s", field.GoName, fullyQualifiedName)),
				jen.If(
					jen.List(jen.Id("fieldDeserializer"), jen.Id("hasFieldDeserializer")).Op(":=").Id("options").Dot("FlagDeserializer").Call(
						jen.Lit(fullyQualifiedName),
					),
					jen.Id("hasFieldDeserializer"),
				).Block(
					jen.Comment("Use custom deserializer for nested message"),
					jen.Comment(fmt.Sprintf("Create FlagContainer for field flag: %s", flagName)),
					jen.Id("fieldFlags").Op(":=").Qual("github.com/drewfead/proto-cli", "NewFlagContainer").Call(
						jen.Id("cmd"),
						jen.Lit(flagName),
					),
					jen.List(jen.Id("fieldMsg"), jen.Id("fieldErr")).Op(":=").Id("fieldDeserializer").Call(
						jen.Id("cmdCtx"),
						jen.Id("fieldFlags"),
					),
					jen.If(jen.Id("fieldErr").Op("!=").Nil()).Block(
						jen.Return(jen.Qual("fmt", "Errorf").Call(
							jen.Lit(fmt.Sprintf("failed to deserialize field %s: %%w", field.GoName)),
							jen.Id("fieldErr"),
						)),
					),
					jen.Comment("Handle nil return from deserializer (means skip/use default)"),
					jen.If(jen.Id("fieldMsg").Op("!=").Nil()).Block(
						jen.List(jen.Id("typedField"), jen.Id("fieldOk")).Op(":=").Id("fieldMsg").Assert(qualifiedType),
						jen.If(jen.Op("!").Id("fieldOk")).Block(
							jen.Return(jen.Qual("fmt", "Errorf").Call(
								jen.Lit(fmt.Sprintf("custom deserializer for %s returned wrong type: expected *%s, got %%T", fullyQualifiedName, goTypeName)),
								jen.Id("fieldMsg"),
							)),
						),
						jen.Id("req").Dot(field.GoName).Op("=").Id("typedField"),
					),
				).Else().Block(
					jen.Comment("No custom deserializer - check if user provided a value"),
					jen.If(jen.Id("cmd").Dot("IsSet").Call(jen.Lit(flagName))).Block(
						jen.Return(jen.Qual("fmt", "Errorf").Call(
							jen.Lit(fmt.Sprintf("flag --%s requires a custom deserializer for %s (register with protocli.WithFlagDeserializer)", flagName, fullyQualifiedName)),
						)),
					),
					jen.Comment("No value provided - leave field as nil"),
				),
			)

		case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
			// Check if field is optional (has synthetic oneof for presence tracking)
			oneof := field.Desc.ContainingOneof()
			isOptional := field.Desc.HasPresence() && (oneof == nil || (oneof != nil && oneof.IsSynthetic()))
			if isOptional {
				// Optional field - only set if flag was provided
				statements = append(statements,
					jen.If(jen.Id("cmd").Dot("IsSet").Call(jen.Lit(flagName))).Block(
						jen.Id("val").Op(":=").Id("cmd").Dot("Int32").Call(jen.Lit(flagName)),
						jen.Id("req").Dot(field.GoName).Op("=").Op("&").Id("val"),
					),
				)
			} else {
				// Regular field - always set
				statements = append(statements,
					jen.Id("req").Dot(field.GoName).Op("=").Id("cmd").Dot("Int32").Call(jen.Lit(flagName)),
				)
			}
		case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
			oneof := field.Desc.ContainingOneof()
			isOptional := field.Desc.HasPresence() && (oneof == nil || (oneof != nil && oneof.IsSynthetic()))
			if isOptional {
				statements = append(statements,
					jen.If(jen.Id("cmd").Dot("IsSet").Call(jen.Lit(flagName))).Block(
						jen.Id("val").Op(":=").Id("cmd").Dot("Int64").Call(jen.Lit(flagName)),
						jen.Id("req").Dot(field.GoName).Op("=").Op("&").Id("val"),
					),
				)
			} else {
				statements = append(statements,
					jen.Id("req").Dot(field.GoName).Op("=").Id("cmd").Dot("Int64").Call(jen.Lit(flagName)),
				)
			}
		case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
			oneof := field.Desc.ContainingOneof()
			isOptional := field.Desc.HasPresence() && (oneof == nil || (oneof != nil && oneof.IsSynthetic()))
			if isOptional {
				statements = append(statements,
					jen.If(jen.Id("cmd").Dot("IsSet").Call(jen.Lit(flagName))).Block(
						jen.Id("val").Op(":=").Id("cmd").Dot("Uint32").Call(jen.Lit(flagName)),
						jen.Id("req").Dot(field.GoName).Op("=").Op("&").Id("val"),
					),
				)
			} else {
				statements = append(statements,
					jen.Id("req").Dot(field.GoName).Op("=").Id("cmd").Dot("Uint32").Call(jen.Lit(flagName)),
				)
			}
		case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
			oneof := field.Desc.ContainingOneof()
			isOptional := field.Desc.HasPresence() && (oneof == nil || (oneof != nil && oneof.IsSynthetic()))
			if isOptional {
				statements = append(statements,
					jen.If(jen.Id("cmd").Dot("IsSet").Call(jen.Lit(flagName))).Block(
						jen.Id("val").Op(":=").Id("cmd").Dot("Uint64").Call(jen.Lit(flagName)),
						jen.Id("req").Dot(field.GoName).Op("=").Op("&").Id("val"),
					),
				)
			} else {
				statements = append(statements,
					jen.Id("req").Dot(field.GoName).Op("=").Id("cmd").Dot("Uint64").Call(jen.Lit(flagName)),
				)
			}
		case protoreflect.FloatKind:
			oneof := field.Desc.ContainingOneof()
			isOptional := field.Desc.HasPresence() && (oneof == nil || (oneof != nil && oneof.IsSynthetic()))
			if isOptional {
				statements = append(statements,
					jen.If(jen.Id("cmd").Dot("IsSet").Call(jen.Lit(flagName))).Block(
						jen.Id("val").Op(":=").Id("cmd").Dot("Float32").Call(jen.Lit(flagName)),
						jen.Id("req").Dot(field.GoName).Op("=").Op("&").Id("val"),
					),
				)
			} else {
				statements = append(statements,
					jen.Id("req").Dot(field.GoName).Op("=").Id("cmd").Dot("Float32").Call(jen.Lit(flagName)),
				)
			}
		case protoreflect.DoubleKind:
			oneof := field.Desc.ContainingOneof()
			isOptional := field.Desc.HasPresence() && (oneof == nil || (oneof != nil && oneof.IsSynthetic()))
			if isOptional {
				statements = append(statements,
					jen.If(jen.Id("cmd").Dot("IsSet").Call(jen.Lit(flagName))).Block(
						jen.Id("val").Op(":=").Id("cmd").Dot("Float64").Call(jen.Lit(flagName)),
						jen.Id("req").Dot(field.GoName).Op("=").Op("&").Id("val"),
					),
				)
			} else {
				statements = append(statements,
					jen.Id("req").Dot(field.GoName).Op("=").Id("cmd").Dot("Float64").Call(jen.Lit(flagName)),
				)
			}
		case protoreflect.StringKind:
			oneof := field.Desc.ContainingOneof()
			isOptional := field.Desc.HasPresence() && (oneof == nil || (oneof != nil && oneof.IsSynthetic()))
			if isOptional {
				statements = append(statements,
					jen.If(jen.Id("cmd").Dot("IsSet").Call(jen.Lit(flagName))).Block(
						jen.Id("val").Op(":=").Id("cmd").Dot("String").Call(jen.Lit(flagName)),
						jen.Id("req").Dot(field.GoName).Op("=").Op("&").Id("val"),
					),
				)
			} else {
				statements = append(statements,
					jen.Id("req").Dot(field.GoName).Op("=").Id("cmd").Dot("String").Call(jen.Lit(flagName)),
				)
			}
		case protoreflect.BoolKind:
			oneof := field.Desc.ContainingOneof()
			isOptional := field.Desc.HasPresence() && (oneof == nil || (oneof != nil && oneof.IsSynthetic()))
			if isOptional {
				statements = append(statements,
					jen.If(jen.Id("cmd").Dot("IsSet").Call(jen.Lit(flagName))).Block(
						jen.Id("val").Op(":=").Id("cmd").Dot("Bool").Call(jen.Lit(flagName)),
						jen.Id("req").Dot(field.GoName).Op("=").Op("&").Id("val"),
					),
				)
			} else {
				statements = append(statements,
					jen.Id("req").Dot(field.GoName).Op("=").Id("cmd").Dot("Bool").Call(jen.Lit(flagName)),
				)
			}
		case protoreflect.BytesKind:
			// Bytes fields don't have explicit presence in proto3, always set
			statements = append(statements,
				jen.Id("req").Dot(field.GoName).Op("=").Index().Byte().Call(
					jen.Id("cmd").Dot("String").Call(jen.Lit(flagName)),
				),
			)
		case protoreflect.EnumKind:
			// Enums don't have explicit presence tracking, always set
			statements = append(statements,
				jen.Id("req").Dot(field.GoName).Op("=").Id("cmd").Dot("Int32").Call(jen.Lit(flagName)),
			)
		case protoreflect.GroupKind:
			// GroupKind is deprecated and not supported - generate runtime error
			fmt.Fprintf(os.Stderr, "WARNING: Field %s uses deprecated GroupKind - generating code that will return a runtime error\n", field.Desc.FullName())
			statements = append(statements,
				jen.Return(jen.Qual("fmt", "Errorf").Call(
					jen.Lit(fmt.Sprintf("field %s uses deprecated proto2 GroupKind which is not supported - please update your proto definition to use a message type instead", field.GoName)),
				)),
			)
		}
	}

	return statements
}

// generateOutputWriterOpening generates code to open the output writer and set up cleanup
func generateOutputWriterOpening() []jen.Code {
	return []jen.Code{
		jen.Comment("Open output writer"),
		jen.List(jen.Id("outputWriter"), jen.Err()).Op(":=").Id("getOutputWriter").Call(
			jen.Id("cmd").Dot("String").Call(jen.Lit("output")),
		),
		jen.If(jen.Err().Op("!=").Nil()).Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("failed to open output: %w"), jen.Err())),
		),
		jen.If(jen.Id("closer").Op(",").Id("ok").Op(":=").Id("outputWriter").Assert(jen.Qual("io", "Closer")), jen.Id("ok")).Block(
			jen.Defer().Id("closer").Dot("Close").Call(),
		),
		jen.Line(),
	}
}

func generateActionBodyWithHooks(file *protogen.File, service *protogen.Service, method *protogen.Method, configMessageType string) []jen.Code {
	var statements []jen.Code

	// Call before hook if set
	statements = append(statements,
		jen.If(jen.Id("options").Dot("BeforeCommand").Call().Op("!=").Nil()).Block(
			jen.If(
				jen.Err().Op(":=").Id("options").Dot("BeforeCommand").Call().Call(
					jen.Id("cmdCtx"),
					jen.Id("cmd"),
				),
				jen.Err().Op("!=").Nil(),
			).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(
					jen.Lit("before hook failed: %w"),
					jen.Err(),
				)),
			),
		),
		jen.Line(),
	)

	// Defer after hook
	statements = append(statements,
		jen.Defer().Func().Params().Block(
			jen.If(jen.Id("options").Dot("AfterCommand").Call().Op("!=").Nil()).Block(
				jen.If(
					jen.Err().Op(":=").Id("options").Dot("AfterCommand").Call().Call(
						jen.Id("cmdCtx"),
						jen.Id("cmd"),
					),
					jen.Err().Op("!=").Nil(),
				).Block(
					jen.Qual("log/slog", "Warn").Call(
						jen.Lit("after hook failed"),
						jen.Lit("error"),
						jen.Err(),
					),
				),
			),
		).Call(),
		jen.Line(),
	)

	// Build request - check for custom deserializer first
	requestFullyQualifiedName := string(method.Input.Desc.FullName())
	requestTypeName := method.Input.GoIdent.GoName
	requestQualifiedType := qualifyType(file, method.Input, true)

	// First, check for custom deserializer
	statements = append(statements,
		jen.Comment("Build request message"),
		jen.Var().Id("req").Add(requestQualifiedType),
		jen.Line(),
	)

	// Generate the if-else block for custom deserializer vs auto-generated
	deserializerCheck := []jen.Code{
		jen.Comment(fmt.Sprintf("Check for custom flag deserializer for %s", requestFullyQualifiedName)),
		jen.List(jen.Id("deserializer"), jen.Id("hasDeserializer")).Op(":=").Id("options").Dot("FlagDeserializer").Call(
			jen.Lit(requestFullyQualifiedName),
		),
		jen.If(jen.Id("hasDeserializer")).Block(
			jen.Comment("Use custom deserializer for top-level request"),
			jen.Comment("Create FlagContainer (deserializer can access multiple flags via Command())"),
			jen.Id("requestFlags").Op(":=").Qual("github.com/drewfead/proto-cli", "NewFlagContainer").Call(
				jen.Id("cmd"),
				jen.Lit(""), // Empty flag name for top-level requests
			),
			jen.List(jen.Id("msg"), jen.Err()).Op(":=").Id("deserializer").Call(
				jen.Id("cmdCtx"),
				jen.Id("requestFlags"),
			),
			jen.If(jen.Err().Op("!=").Nil()).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(
					jen.Lit("custom deserializer failed: %w"),
					jen.Err(),
				)),
			),
			jen.Comment("Handle nil return from deserializer"),
			jen.If(jen.Id("msg").Op("==").Nil()).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(
					jen.Lit("custom deserializer returned nil message"),
				)),
			),
			jen.Var().Id("ok").Bool(),
			jen.List(jen.Id("req"), jen.Id("ok")).Op("=").Id("msg").Assert(requestQualifiedType),
			jen.If(jen.Op("!").Id("ok")).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(
					jen.Lit("custom deserializer returned wrong type: expected *%s, got %T"),
					jen.Lit(requestTypeName),
					jen.Id("msg"),
				)),
			),
		).Else().Block(
			append([]jen.Code{
				jen.Comment("Use auto-generated flag parsing"),
				jen.Id("req").Op("=").Op("&").Add(qualifyType(file, method.Input, false)).Values(),
			}, generateRequestFieldAssignments(file, method)...)...,
		),
		jen.Line(),
	}

	statements = append(statements, deserializerCheck...)

	// Check if remote flag is set and call either remote or direct
	clientType := "New" + service.GoName + "Client"
	statements = append(statements,
		jen.Comment("Check if using remote gRPC call or direct implementation call"),
		jen.Id("remoteAddr").Op(":=").Id("cmd").Dot("String").Call(jen.Lit("remote")),
		jen.Var().Id("resp").Op("*").Id(method.Output.GoIdent.GoName),
		jen.Var().Err().Error(),
		jen.Line(),
		jen.If(jen.Id("remoteAddr").Op("!=").Lit("")).Block(
			jen.Comment("Remote gRPC call"),
			jen.List(jen.Id("conn"), jen.Id("connErr")).Op(":=").Qual("google.golang.org/grpc", "NewClient").Call(
				jen.Id("remoteAddr"),
				jen.Qual("google.golang.org/grpc", "WithTransportCredentials").Call(
					jen.Qual("google.golang.org/grpc/credentials/insecure", "NewCredentials").Call(),
				),
			),
			jen.If(jen.Id("connErr").Op("!=").Nil()).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(
					jen.Lit("failed to connect to remote %s: %w"),
					jen.Id("remoteAddr"),
					jen.Id("connErr"),
				)),
			),
			jen.Defer().Id("conn").Dot("Close").Call(),
			jen.Line(),
			jen.Id("client").Op(":=").Id(clientType).Call(jen.Id("conn")),
			jen.List(jen.Id("resp"), jen.Err()).Op("=").Id("client").Dot(method.GoName).Call(
				jen.Id("cmdCtx"),
				jen.Id("req"),
			),
			jen.If(jen.Err().Op("!=").Nil()).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("remote call failed: %w"), jen.Err())),
			),
		).Else().Block(
			generateLocalCallLogic(service, method, configMessageType)...,
		),
		jen.Line(),
	)

	// Handle output formatting
	statements = append(statements, generateOutputWriterOpening()...)

	statements = append(statements,
		jen.Comment("Find and use the appropriate output format"),
		jen.Id("formatName").Op(":=").Id("cmd").Dot("String").Call(jen.Lit("format")),
		jen.Line(),
		jen.Comment("Try registered formats"),
		jen.For(
			jen.List(jen.Id("_"), jen.Id("outputFmt")).Op(":=").Range().Id("options").Dot("OutputFormats").Call(),
		).Block(
			jen.If(jen.Id("outputFmt").Dot("Name").Call().Op("==").Id("formatName")).Block(
				jen.If(
					jen.Err().Op(":=").Id("outputFmt").Dot("Format").Call(
						jen.Id("cmdCtx"),
						jen.Id("cmd"),
						jen.Id("outputWriter"),
						jen.Id("resp"),
					),
					jen.Err().Op("!=").Nil(),
				).Block(
					jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("format failed: %w"), jen.Err())),
				),
				jen.Comment("Write final newline to keep terminal clean"),
				jen.If(
					jen.List(jen.Id("_"), jen.Err()).Op(":=").Id("outputWriter").Dot("Write").Call(
						jen.Index().Byte().Call(jen.Lit("\n")),
					),
					jen.Err().Op("!=").Nil(),
				).Block(
					jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("failed to write final newline: %w"), jen.Err())),
				),
				jen.Return(jen.Nil()),
			),
		),
		jen.Line(),
		jen.Comment("Format not found - build list of available formats"),
		jen.Var().Id("availableFormats").Index().String(),
		jen.For(
			jen.List(jen.Id("_"), jen.Id("f")).Op(":=").Range().Id("options").Dot("OutputFormats").Call(),
		).Block(
			jen.Id("availableFormats").Op("=").Append(
				jen.Id("availableFormats"),
				jen.Id("f").Dot("Name").Call(),
			),
		),
		jen.If(jen.Len(jen.Id("availableFormats")).Op("==").Lit(0)).Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(
				jen.Lit("no output formats registered (use WithOutputFormats to register formats)"),
			)),
		),
		jen.Return(jen.Qual("fmt", "Errorf").Call(
			jen.Lit("unknown format %q (available: %v)"),
			jen.Id("formatName"),
			jen.Id("availableFormats"),
		)),
	)

	return statements
}

// generateLocalCallLogic generates the logic for calling the service implementation locally
func generateLocalCallLogic(service *protogen.Service, method *protogen.Method, configMessageType string) []jen.Code {
	var statements []jen.Code

	if configMessageType != "" {
		// Service has config - need to load it and call factory
		statements = append(statements,
			jen.Comment("Load config and create service implementation"),
			jen.Comment("Get config paths and env prefix from root command"),
			jen.Id("rootCmd").Op(":=").Id("cmd").Dot("Root").Call(),
			jen.Id("configPaths").Op(":=").Id("rootCmd").Dot("StringSlice").Call(jen.Lit("config")),
			jen.Id("envPrefix").Op(":=").Id("rootCmd").Dot("String").Call(jen.Lit("env-prefix")),
			jen.Line(),
			jen.Comment("Create config loader (single-command mode = uses files + env + flags)"),
			jen.Id("loader").Op(":=").Qual("github.com/drewfead/proto-cli", "NewConfigLoader").Call(
				jen.Qual("github.com/drewfead/proto-cli", "SingleCommandMode"),
				jen.Qual("github.com/drewfead/proto-cli", "FileConfig").Call(jen.Id("configPaths").Op("...")),
				jen.Qual("github.com/drewfead/proto-cli", "EnvPrefix").Call(jen.Id("envPrefix")),
			),
			jen.Line(),
			jen.Comment("Create config instance and load configuration"),
			jen.Id("config").Op(":=").Op("&").Id(configMessageType).Values(),
			jen.If(
				jen.Err().Op(":=").Id("loader").Dot("LoadServiceConfig").Call(
					jen.Id("cmd"),
					jen.Lit(strings.ToLower(service.GoName)),
					jen.Id("config"),
				),
				jen.Err().Op("!=").Nil(),
			).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("failed to load config: %w"), jen.Err())),
			),
			jen.Line(),
			jen.Comment("Call factory to create service implementation"),
			jen.List(jen.Id("svcImpl"), jen.Err()).Op(":=").Qual("github.com/drewfead/proto-cli", "CallFactory").Call(
				jen.Id("implOrFactory"),
				jen.Id("config"),
			),
			jen.If(jen.Err().Op("!=").Nil()).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("failed to create service: %w"), jen.Err())),
			),
			jen.Line(),
			jen.Comment("Call the RPC method"),
			jen.List(jen.Id("resp"), jen.Err()).Op("=").Id("svcImpl").Assert(jen.Id(service.GoName+"Server")).Dot(method.GoName).Call(
				jen.Id("cmdCtx"),
				jen.Id("req"),
			),
			jen.If(jen.Err().Op("!=").Nil()).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("method failed: %w"), jen.Err())),
			),
		)
	} else {
		// No config - direct implementation call
		statements = append(statements,
			jen.Comment("Direct implementation call (no config)"),
			jen.Id("svcImpl").Op(":=").Id("implOrFactory").Assert(jen.Id(service.GoName+"Server")),
			jen.List(jen.Id("resp"), jen.Err()).Op("=").Id("svcImpl").Dot(method.GoName).Call(
				jen.Id("cmdCtx"),
				jen.Id("req"),
			),
			jen.If(jen.Err().Op("!=").Nil()).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("method failed: %w"), jen.Err())),
			),
		)
	}

	return statements
}

// generateServerStreamingCommand generates a CLI command for server streaming RPC methods
func generateServerStreamingCommand(service *protogen.Service, method *protogen.Method, configMessageType string, file *protogen.File) []jen.Code {
	var statements []jen.Code

	// Get command name from annotation or use kebab-case default
	cmdName := toKebabCase(method.GoName)
	cmdUsage := method.GoName + " (streaming)"

	cmdOpts := getMethodCommandOptions(method)
	if cmdOpts != nil {
		if cmdOpts.Name != "" {
			cmdName = cmdOpts.Name
		}
		if cmdOpts.Description != "" {
			cmdUsage = cmdOpts.Description
		}
	}

	// Create a safe variable name (replace hyphens with underscores)
	cmdVarName := strings.ReplaceAll(cmdName, "-", "_")

	// Build flags dynamically with output format support and delimiter
	statements = append(statements,
		jen.Comment("Build flags for "+cmdName),
		jen.Id("flags_"+cmdVarName).Op(":=").Index().Qual("github.com/urfave/cli/v3", "Flag").Values(
			jen.Op("&").Qual("github.com/urfave/cli/v3", "StringFlag").Values(jen.Dict{
				jen.Id("Name"):  jen.Lit("remote"),
				jen.Id("Usage"): jen.Lit("Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call"),
			}),
			jen.Op("&").Qual("github.com/urfave/cli/v3", "StringFlag").Values(jen.Dict{
				jen.Id("Name"):  jen.Lit("format"),
				jen.Id("Value"): jen.Id("defaultFormat"),
				jen.Id("Usage"): jen.Lit("Output format (use --format to see available formats)"),
			}),
			jen.Op("&").Qual("github.com/urfave/cli/v3", "StringFlag").Values(jen.Dict{
				jen.Id("Name"):  jen.Lit("output"),
				jen.Id("Value"): jen.Lit("-"),
				jen.Id("Usage"): jen.Lit("Output file (- for stdout)"),
			}),
			jen.Op("&").Qual("github.com/urfave/cli/v3", "StringFlag").Values(jen.Dict{
				jen.Id("Name"):  jen.Lit("delimiter"),
				jen.Id("Value"): jen.Lit("\n"),
				jen.Id("Usage"): jen.Lit("Delimiter between streamed messages"),
			}),
		),
		jen.Line(),
	)

	// Add request field flags
	for _, field := range method.Input.Fields {
		flagCode := generateFlag(field)
		if flagCode != nil {
			statements = append(statements,
				jen.Id("flags_"+cmdVarName).Op("=").Append(jen.Id("flags_"+cmdVarName), flagCode),
			)
		}
	}

	// Add config field flags if service has config
	statements = append(statements, generateConfigFlags(file, configMessageType, cmdVarName)...)

	// Add format-specific flags from registered formats
	statements = append(statements,
		jen.Line(),
		jen.Comment("Add format-specific flags from registered formats"),
		jen.For(
			jen.List(jen.Id("_"), jen.Id("outputFmt")).Op(":=").Range().Id("options").Dot("OutputFormats").Call(),
		).Block(
			jen.Comment("Check if format implements FlagConfiguredOutputFormat"),
			jen.If(
				jen.List(jen.Id("flagConfigured"), jen.Id("ok")).Op(":=").Id("outputFmt").Assert(
					jen.Qual("github.com/drewfead/proto-cli", "FlagConfiguredOutputFormat"),
				),
				jen.Id("ok"),
			).Block(
				jen.Id("flags_"+cmdVarName).Op("=").Append(
					jen.Id("flags_"+cmdVarName),
					jen.Id("flagConfigured").Dot("Flags").Call().Op("..."),
				),
			),
		),
		jen.Line(),
	)

	// Generate the command with streaming action
	statements = append(statements,
		jen.Id("commands").Op("=").Append(
			jen.Id("commands"),
			jen.Op("&").Qual("github.com/urfave/cli/v3", "Command").Values(jen.Dict{
				jen.Id("Name"):  jen.Lit(cmdName),
				jen.Id("Usage"): jen.Lit(cmdUsage),
				jen.Id("Flags"): jen.Id("flags_" + cmdVarName),
				jen.Id("Action"): jen.Func().Params(
					jen.Id("cmdCtx").Qual("context", "Context"),
					jen.Id("cmd").Op("*").Qual("github.com/urfave/cli/v3", "Command"),
				).Error().Block(
					generateServerStreamingActionBody(file, service, method, configMessageType)...,
				),
			}),
		),
		jen.Line(),
	)

	return statements
}

// generateServerStreamingActionBody generates the action body for server streaming commands
func generateServerStreamingActionBody(file *protogen.File, service *protogen.Service, method *protogen.Method, configMessageType string) []jen.Code {
	var statements []jen.Code

	// Call before hook if set
	statements = append(statements,
		jen.If(jen.Id("options").Dot("BeforeCommand").Call().Op("!=").Nil()).Block(
			jen.If(
				jen.Err().Op(":=").Id("options").Dot("BeforeCommand").Call().Call(
					jen.Id("cmdCtx"),
					jen.Id("cmd"),
				),
				jen.Err().Op("!=").Nil(),
			).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(
					jen.Lit("before hook failed: %w"),
					jen.Err(),
				)),
			),
		),
		jen.Line(),
	)

	// Defer after hook
	statements = append(statements,
		jen.Defer().Func().Params().Block(
			jen.If(jen.Id("options").Dot("AfterCommand").Call().Op("!=").Nil()).Block(
				jen.If(
					jen.Err().Op(":=").Id("options").Dot("AfterCommand").Call().Call(
						jen.Id("cmdCtx"),
						jen.Id("cmd"),
					),
					jen.Err().Op("!=").Nil(),
				).Block(
					jen.Qual("log/slog", "Warn").Call(
						jen.Lit("after hook failed"),
						jen.Lit("error"),
						jen.Err(),
					),
				),
			),
		).Call(),
		jen.Line(),
	)

	// Build request (same as unary)
	requestFullyQualifiedName := string(method.Input.Desc.FullName())
	requestTypeName := method.Input.GoIdent.GoName
	requestQualifiedType := qualifyType(file, method.Input, true)

	statements = append(statements,
		jen.Comment("Build request message"),
		jen.Var().Id("req").Add(requestQualifiedType),
		jen.Line(),
	)

	// Generate the if-else block for custom deserializer vs auto-generated
	deserializerCheck := []jen.Code{
		jen.Comment(fmt.Sprintf("Check for custom flag deserializer for %s", requestFullyQualifiedName)),
		jen.List(jen.Id("deserializer"), jen.Id("hasDeserializer")).Op(":=").Id("options").Dot("FlagDeserializer").Call(
			jen.Lit(requestFullyQualifiedName),
		),
		jen.If(jen.Id("hasDeserializer")).Block(
			jen.Comment("Use custom deserializer for top-level request"),
			jen.Id("requestFlags").Op(":=").Qual("github.com/drewfead/proto-cli", "NewFlagContainer").Call(
				jen.Id("cmd"),
				jen.Lit(""),
			),
			jen.List(jen.Id("msg"), jen.Err()).Op(":=").Id("deserializer").Call(
				jen.Id("cmdCtx"),
				jen.Id("requestFlags"),
			),
			jen.If(jen.Err().Op("!=").Nil()).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(
					jen.Lit("custom deserializer failed: %w"),
					jen.Err(),
				)),
			),
			jen.If(jen.Id("msg").Op("==").Nil()).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(
					jen.Lit("custom deserializer returned nil message"),
				)),
			),
			jen.Var().Id("ok").Bool(),
			jen.List(jen.Id("req"), jen.Id("ok")).Op("=").Id("msg").Assert(requestQualifiedType),
			jen.If(jen.Op("!").Id("ok")).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(
					jen.Lit("custom deserializer returned wrong type: expected *%s, got %T"),
					jen.Lit(requestTypeName),
					jen.Id("msg"),
				)),
			),
		).Else().Block(
			append([]jen.Code{
				jen.Comment("Use auto-generated flag parsing"),
				jen.Id("req").Op("=").Op("&").Add(qualifyType(file, method.Input, false)).Values(),
			}, generateRequestFieldAssignments(file, method)...)...,
		),
		jen.Line(),
	}

	statements = append(statements, deserializerCheck...)

	// Open output writer
	statements = append(statements, generateOutputWriterOpening()...)

	// Find output format
	statements = append(statements,
		jen.Comment("Find the appropriate output format"),
		jen.Id("formatName").Op(":=").Id("cmd").Dot("String").Call(jen.Lit("format")),
		jen.Var().Id("outputFmt").Qual("github.com/drewfead/proto-cli", "OutputFormat"),
		jen.For(
			jen.List(jen.Id("_"), jen.Id("f")).Op(":=").Range().Id("options").Dot("OutputFormats").Call(),
		).Block(
			jen.If(jen.Id("f").Dot("Name").Call().Op("==").Id("formatName")).Block(
				jen.Id("outputFmt").Op("=").Id("f"),
				jen.Break(),
			),
		),
		jen.If(jen.Id("outputFmt").Op("==").Nil()).Block(
			jen.Var().Id("availableFormats").Index().String(),
			jen.For(
				jen.List(jen.Id("_"), jen.Id("f")).Op(":=").Range().Id("options").Dot("OutputFormats").Call(),
			).Block(
				jen.Id("availableFormats").Op("=").Append(
					jen.Id("availableFormats"),
					jen.Id("f").Dot("Name").Call(),
				),
			),
			jen.Return(jen.Qual("fmt", "Errorf").Call(
				jen.Lit("unknown format %q (available: %v)"),
				jen.Id("formatName"),
				jen.Id("availableFormats"),
			)),
		),
		jen.Line(),
	)

	// Get delimiter
	statements = append(statements,
		jen.Comment("Get delimiter for separating streamed messages"),
		jen.Id("delimiter").Op(":=").Id("cmd").Dot("String").Call(jen.Lit("delimiter")),
		jen.Line(),
	)

	// Check if remote or local call
	clientType := "New" + service.GoName + "Client"
	statements = append(statements,
		jen.Comment("Check if using remote gRPC call or direct implementation call"),
		jen.Id("remoteAddr").Op(":=").Id("cmd").Dot("String").Call(jen.Lit("remote")),
		jen.Line(),
		jen.If(jen.Id("remoteAddr").Op("!=").Lit("")).Block(
			generateRemoteStreamingCall(service, method, clientType)...,
		).Else().Block(
			generateLocalStreamingCall(service, method, configMessageType)...,
		),
		jen.Line(),
		jen.Return(jen.Nil()),
	)

	return statements
}

// generateRemoteStreamingCall generates code for remote streaming gRPC calls
func generateRemoteStreamingCall(_ *protogen.Service, method *protogen.Method, clientType string) []jen.Code {
	return []jen.Code{
		jen.Comment("Remote gRPC streaming call"),
		jen.List(jen.Id("conn"), jen.Id("connErr")).Op(":=").Qual("google.golang.org/grpc", "NewClient").Call(
			jen.Id("remoteAddr"),
			jen.Qual("google.golang.org/grpc", "WithTransportCredentials").Call(
				jen.Qual("google.golang.org/grpc/credentials/insecure", "NewCredentials").Call(),
			),
		),
		jen.If(jen.Id("connErr").Op("!=").Nil()).Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(
				jen.Lit("failed to connect to remote %s: %w"),
				jen.Id("remoteAddr"),
				jen.Id("connErr"),
			)),
		),
		jen.Defer().Id("conn").Dot("Close").Call(),
		jen.Line(),
		jen.Id("client").Op(":=").Id(clientType).Call(jen.Id("conn")),
		jen.List(jen.Id("stream"), jen.Err()).Op(":=").Id("client").Dot(method.GoName).Call(
			jen.Id("cmdCtx"),
			jen.Id("req"),
		),
		jen.If(jen.Err().Op("!=").Nil()).Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("failed to start stream: %w"), jen.Err())),
		),
		jen.Line(),
		jen.Comment("Receive and format each message in the stream"),
		jen.Var().Id("messageCount").Int(),
		jen.For().Block(
			jen.List(jen.Id("msg"), jen.Id("recvErr")).Op(":=").Id("stream").Dot("Recv").Call(),
			jen.If(jen.Id("recvErr").Op("==").Qual("io", "EOF")).Block(
				jen.Break(),
			),
			jen.If(jen.Id("recvErr").Op("!=").Nil()).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("stream receive error: %w"), jen.Id("recvErr"))),
			),
			jen.Line(),
			jen.Comment("Format and write the message"),
			jen.If(
				jen.Err().Op(":=").Id("outputFmt").Dot("Format").Call(
					jen.Id("cmdCtx"),
					jen.Id("cmd"),
					jen.Id("outputWriter"),
					jen.Id("msg"),
				),
				jen.Err().Op("!=").Nil(),
			).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("format failed: %w"), jen.Err())),
			),
			jen.Line(),
			jen.Comment("Write delimiter"),
			jen.If(
				jen.List(jen.Id("_"), jen.Err()).Op(":=").Id("outputWriter").Dot("Write").Call(
					jen.Index().Byte().Call(jen.Id("delimiter")),
				),
				jen.Err().Op("!=").Nil(),
			).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("failed to write delimiter: %w"), jen.Err())),
			),
			jen.Id("messageCount").Op("++"),
		),
		jen.Line(),
		jen.Comment("Write final newline to keep terminal clean (only if delimiter doesn't already end with newline)"),
		jen.If(
			jen.Id("messageCount").Op(">").Lit(0).Op("&&").Op("!").Qual("strings", "HasSuffix").Call(
				jen.Id("delimiter"),
				jen.Lit("\n"),
			),
		).Block(
			jen.If(
				jen.List(jen.Id("_"), jen.Err()).Op(":=").Id("outputWriter").Dot("Write").Call(
					jen.Index().Byte().Call(jen.Lit("\n")),
				),
				jen.Err().Op("!=").Nil(),
			).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("failed to write final newline: %w"), jen.Err())),
			),
		),
	}
}

// generateLocalStreamingCall generates code for local streaming calls
func generateLocalStreamingCall(service *protogen.Service, method *protogen.Method, configMessageType string) []jen.Code {
	var statements []jen.Code

	responseType := method.Output.GoIdent.GoName
	streamTypeName := "localServerStream_" + method.GoName

	if configMessageType != "" {
		// Service has config - need to load it and call factory
		statements = append(statements,
			jen.Comment("Load config and create service implementation"),
			jen.Id("rootCmd").Op(":=").Id("cmd").Dot("Root").Call(),
			jen.Id("configPaths").Op(":=").Id("rootCmd").Dot("StringSlice").Call(jen.Lit("config")),
			jen.Id("envPrefix").Op(":=").Id("rootCmd").Dot("String").Call(jen.Lit("env-prefix")),
			jen.Line(),
			jen.Id("loader").Op(":=").Qual("github.com/drewfead/proto-cli", "NewConfigLoader").Call(
				jen.Qual("github.com/drewfead/proto-cli", "SingleCommandMode"),
				jen.Qual("github.com/drewfead/proto-cli", "FileConfig").Call(jen.Id("configPaths").Op("...")),
				jen.Qual("github.com/drewfead/proto-cli", "EnvPrefix").Call(jen.Id("envPrefix")),
			),
			jen.Line(),
			jen.Id("config").Op(":=").Op("&").Id(configMessageType).Values(),
			jen.If(
				jen.Err().Op(":=").Id("loader").Dot("LoadServiceConfig").Call(
					jen.Id("cmd"),
					jen.Lit(strings.ToLower(service.GoName)),
					jen.Id("config"),
				),
				jen.Err().Op("!=").Nil(),
			).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("failed to load config: %w"), jen.Err())),
			),
			jen.Line(),
			jen.List(jen.Id("svcImpl"), jen.Err()).Op(":=").Qual("github.com/drewfead/proto-cli", "CallFactory").Call(
				jen.Id("implOrFactory"),
				jen.Id("config"),
			),
			jen.If(jen.Err().Op("!=").Nil()).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("failed to create service: %w"), jen.Err())),
			),
			jen.Line(),
		)
	} else {
		// No config - direct implementation call
		statements = append(statements,
			jen.Comment("Direct implementation call (no config)"),
			jen.Id("svcImpl").Op(":=").Id("implOrFactory").Assert(jen.Id(service.GoName+"Server")),
			jen.Line(),
		)
	}

	// Create local stream wrapper and call method
	statements = append(statements,
		jen.Comment("Create local stream wrapper for direct call"),
		jen.Id("localStream").Op(":=").Op("&").Id(streamTypeName).Values(jen.Dict{
			jen.Id("ctx"):       jen.Id("cmdCtx"),
			jen.Id("responses"): jen.Make(jen.Chan().Op("*").Id(responseType)),
			jen.Id("errors"):    jen.Make(jen.Chan().Error()),
		}),
		jen.Line(),
	)

	// Generate the method call inside goroutine (different based on config)
	var methodCallStmt jen.Code
	if configMessageType != "" {
		methodCallStmt = jen.Id("methodErr").Op("=").Id("svcImpl").Assert(jen.Id(service.GoName+"Server")).Dot(method.GoName).Call(
			jen.Id("req"),
			jen.Id("localStream"),
		)
	} else {
		methodCallStmt = jen.Id("methodErr").Op("=").Id("svcImpl").Dot(method.GoName).Call(
			jen.Id("req"),
			jen.Id("localStream"),
		)
	}

	statements = append(statements,
		jen.Comment("Call streaming method in goroutine"),
		jen.Go().Func().Params().Block(
			jen.Var().Id("methodErr").Error(),
			methodCallStmt,
			jen.Close(jen.Id("localStream").Dot("responses")),
			jen.If(jen.Id("methodErr").Op("!=").Nil()).Block(
				jen.Id("localStream").Dot("errors").Op("<-").Id("methodErr"),
			),
			jen.Close(jen.Id("localStream").Dot("errors")),
		).Call(),
		jen.Line(),
		jen.Comment("Receive and format each message in the stream"),
		jen.Var().Id("messageCount").Int(),
		jen.For().Block(
			jen.Select().Block(
				jen.Case(jen.List(jen.Id("msg"), jen.Id("ok")).Op(":=").Op("<-").Id("localStream").Dot("responses")).Block(
					jen.If(jen.Op("!").Id("ok")).Block(
						jen.Comment("Stream closed, check for errors"),
						jen.If(jen.Id("streamErr").Op(":=").Op("<-").Id("localStream").Dot("errors"), jen.Id("streamErr").Op("!=").Nil()).Block(
							jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("stream error: %w"), jen.Id("streamErr"))),
						),
						jen.Comment("Write final newline to keep terminal clean (only if delimiter doesn't already end with newline)"),
						jen.If(
							jen.Id("messageCount").Op(">").Lit(0).Op("&&").Op("!").Qual("strings", "HasSuffix").Call(
								jen.Id("delimiter"),
								jen.Lit("\n"),
							),
						).Block(
							jen.If(
								jen.List(jen.Id("_"), jen.Err()).Op(":=").Id("outputWriter").Dot("Write").Call(
									jen.Index().Byte().Call(jen.Lit("\n")),
								),
								jen.Err().Op("!=").Nil(),
							).Block(
								jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("failed to write final newline: %w"), jen.Err())),
							),
						),
						jen.Return(jen.Nil()),
					),
					jen.Line(),
					jen.Comment("Format and write the message"),
					jen.If(
						jen.Err().Op(":=").Id("outputFmt").Dot("Format").Call(
							jen.Id("cmdCtx"),
							jen.Id("cmd"),
							jen.Id("outputWriter"),
							jen.Id("msg"),
						),
						jen.Err().Op("!=").Nil(),
					).Block(
						jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("format failed: %w"), jen.Err())),
					),
					jen.Line(),
					jen.Comment("Write delimiter"),
					jen.If(
						jen.List(jen.Id("_"), jen.Err()).Op(":=").Id("outputWriter").Dot("Write").Call(
							jen.Index().Byte().Call(jen.Id("delimiter")),
						),
						jen.Err().Op("!=").Nil(),
					).Block(
						jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("failed to write delimiter: %w"), jen.Err())),
					),
					jen.Id("messageCount").Op("++"),
				),
				jen.Case(jen.Op("<-").Id("cmdCtx").Dot("Done").Call()).Block(
					jen.Return(jen.Id("cmdCtx").Dot("Err").Call()),
				),
			),
		),
	)

	return statements
}

// generateLocalStreamWrapper generates a helper type for local streaming calls
// This is generated at the package level (not inside a function)
func generateLocalStreamWrapper(f *jen.File, method *protogen.Method) {
	streamTypeName := "localServerStream_" + method.GoName
	responseType := method.Output.GoIdent.GoName

	f.Comment(fmt.Sprintf("%s is a helper type for local server streaming calls to %s", streamTypeName, method.GoName))
	f.Type().Id(streamTypeName).Struct(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("responses").Chan().Op("*").Id(responseType),
		jen.Id("errors").Chan().Error(),
	)
	f.Line()

	// Send method
	f.Func().Params(
		jen.Id("s").Op("*").Id(streamTypeName),
	).Id("Send").Params(
		jen.Id("resp").Op("*").Id(responseType),
	).Error().Block(
		jen.Select().Block(
			jen.Case(jen.Id("s").Dot("responses").Op("<-").Id("resp")).Block(
				jen.Return(jen.Nil()),
			),
			jen.Case(jen.Op("<-").Id("s").Dot("ctx").Dot("Done").Call()).Block(
				jen.Return(jen.Id("s").Dot("ctx").Dot("Err").Call()),
			),
		),
	)
	f.Line()

	// Context method
	f.Func().Params(
		jen.Id("s").Op("*").Id(streamTypeName),
	).Id("Context").Params().Qual("context", "Context").Block(
		jen.Return(jen.Id("s").Dot("ctx")),
	)
	f.Line()

	// SetHeader method (no-op for local calls)
	f.Func().Params(
		jen.Id("s").Op("*").Id(streamTypeName),
	).Id("SetHeader").Params(
		jen.Qual("google.golang.org/grpc/metadata", "MD"),
	).Error().Block(
		jen.Return(jen.Nil()),
	)
	f.Line()

	// SendHeader method (no-op for local calls)
	f.Func().Params(
		jen.Id("s").Op("*").Id(streamTypeName),
	).Id("SendHeader").Params(
		jen.Qual("google.golang.org/grpc/metadata", "MD"),
	).Error().Block(
		jen.Return(jen.Nil()),
	)
	f.Line()

	// SetTrailer method (no-op for local calls)
	f.Func().Params(
		jen.Id("s").Op("*").Id(streamTypeName),
	).Id("SetTrailer").Params(
		jen.Qual("google.golang.org/grpc/metadata", "MD"),
	).Block()
	f.Line()

	// SendMsg method (delegates to Send)
	f.Func().Params(
		jen.Id("s").Op("*").Id(streamTypeName),
	).Id("SendMsg").Params(
		jen.Id("m").Any(),
	).Error().Block(
		jen.List(jen.Id("msg"), jen.Id("ok")).Op(":=").Id("m").Assert(jen.Op("*").Id(responseType)),
		jen.If(jen.Op("!").Id("ok")).Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(
				jen.Lit("invalid message type: expected *%s, got %T"),
				jen.Lit(responseType),
				jen.Id("m"),
			)),
		),
		jen.Return(jen.Id("s").Dot("Send").Call(jen.Id("msg"))),
	)
	f.Line()

	// RecvMsg method (not used for server streaming, but required by interface)
	f.Func().Params(
		jen.Id("s").Op("*").Id(streamTypeName),
	).Id("RecvMsg").Params(
		jen.Id("m").Any(),
	).Error().Block(
		jen.Return(jen.Qual("fmt", "Errorf").Call(
			jen.Lit("RecvMsg not supported on server streaming"),
		)),
	)
	f.Line()
}
