package main

import (
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/drewfead/proto-cli/internal/clipb"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Services) == 0 {
		return
	}

	for _, service := range file.Services {
		generateServiceCLI(gen, file, service)
	}
}

// getServiceConfigOptions extracts the service_config extension from service options
func getServiceConfigOptions(service *protogen.Service) *clipb.ServiceConfigOptions {
	opts := service.Desc.Options()
	if opts == nil {
		return nil
	}

	if !proto.HasExtension(opts, clipb.E_ServiceConfig) {
		return nil
	}

	ext := proto.GetExtension(opts, clipb.E_ServiceConfig)
	if ext == nil {
		return nil
	}

	return ext.(*clipb.ServiceConfigOptions)
}

func generateServiceCLI(gen *protogen.Plugin, file *protogen.File, service *protogen.Service) {
	filename := file.GeneratedFilenamePrefix + "_cli.pb.go"

	f := jen.NewFile(string(file.GoPackageName))
	f.HeaderComment("Code generated by protoc-gen-cli. DO NOT EDIT.")
	f.Line()

	// Generate helper function for output writer
	f.Comment("getOutputWriter opens the specified output file or returns stdout")
	f.Func().Id("getOutputWriter").Params(
		jen.Id("path").String(),
	).Params(jen.Qual("io", "Writer"), jen.Error()).Block(
		jen.If(jen.Id("path").Op("==").Lit("-").Op("||").Id("path").Op("==").Lit("")).Block(
			jen.Return(jen.Qual("os", "Stdout"), jen.Nil()),
		),
		jen.Return(jen.Qual("os", "Create").Call(jen.Id("path"))),
	)
	f.Line()

	// Generate the ServiceCommand function
	funcName := service.GoName + "ServiceCommand"

	f.Commentf("%s creates a service CLI for %s with options", funcName, service.GoName)
	f.Commentf("The implOrFactory parameter can be either a direct service implementation or a factory function")
	f.Func().Id(funcName).Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("implOrFactory").Interface(),
		jen.Id("opts").Op("...").Qual("github.com/drewfead/proto-cli", "ServiceOption"),
	).Op("*").Qual("github.com/drewfead/proto-cli", "ServiceCLI").Block(
		generateServiceCommands(file, service)...,
	)

	// Write the generated code
	content := f.GoString()
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P(content)
}

func generateServiceCommands(file *protogen.File, service *protogen.Service) []jen.Code {
	var statements []jen.Code

	// Check for service config annotation
	configOpts := getServiceConfigOptions(service)
	var configMessageType string
	if configOpts != nil && configOpts.ConfigMessage != "" {
		configMessageType = configOpts.ConfigMessage
	}

	// Apply service options
	statements = append(statements,
		jen.Id("options").Op(":=").Qual("github.com/drewfead/proto-cli", "ApplyServiceOptions").Call(jen.Id("opts").Op("...")),
		jen.Line(),
	)

	// Determine default format
	statements = append(statements,
		jen.Comment("Determine default format (first registered format, or empty if none)"),
		jen.Var().Id("defaultFormat").String(),
		jen.If(jen.Len(jen.Id("options").Dot("OutputFormats").Call()).Op(">").Lit(0)).Block(
			jen.Id("defaultFormat").Op("=").Id("options").Dot("OutputFormats").Call().Index(jen.Lit(0)).Dot("Name").Call(),
		),
		jen.Line(),
	)

	// Create commands slice
	statements = append(statements,
		jen.Var().Id("commands").Index().Op("*").Qual("github.com/urfave/cli/v3", "Command"),
		jen.Line(),
	)

	// Generate command for each method
	for _, method := range service.Methods {
		// Skip streaming RPCs
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			continue
		}

		statements = append(statements, generateMethodCommand(service, method, configMessageType, file)...)
	}

	// Return ServiceCLI with command and register function
	serviceName := strings.ToLower(service.GoName)
	registerFunc := "Register" + service.GoName + "Server"

	// Build the ServiceCLI dict
	serviceCLIDict := jen.Dict{
		jen.Id("Command"): jen.Op("&").Qual("github.com/urfave/cli/v3", "Command").Values(jen.Dict{
			jen.Id("Name"):     jen.Lit(serviceName),
			jen.Id("Usage"):    jen.Lit("CLI for " + service.GoName),
			jen.Id("Commands"): jen.Id("commands"),
		}),
		jen.Id("ServiceName"):       jen.Lit(serviceName),
		jen.Id("ConfigMessageType"): jen.Lit(configMessageType),
		jen.Id("FactoryOrImpl"):     jen.Id("implOrFactory"),
		jen.Id("RegisterFunc"): jen.Func().Params(
			jen.Id("s").Op("*").Qual("google.golang.org/grpc", "Server"),
			jen.Id("impl").Interface(),
		).Block(
			jen.Id(registerFunc).Call(
				jen.Id("s"),
				jen.Id("impl").Assert(jen.Id(service.GoName+"Server")),
			),
		),
	}

	// Add ConfigPrototype if there's a config message
	if configMessageType != "" {
		serviceCLIDict[jen.Id("ConfigPrototype")] = jen.Op("&").Id(configMessageType).Values()
	}

	statements = append(statements,
		jen.Line(),
		jen.Return(jen.Op("&").Qual("github.com/drewfead/proto-cli", "ServiceCLI").Values(serviceCLIDict)),
	)

	return statements
}

func generateMethodCommand(service *protogen.Service, method *protogen.Method, configMessageType string, file *protogen.File) []jen.Code {
	var statements []jen.Code

	cmdName := strings.ToLower(method.GoName)

	// Build flags dynamically with output format support
	statements = append(statements,
		jen.Comment("Build flags for "+cmdName),
		jen.Id("flags_"+cmdName).Op(":=").Index().Qual("github.com/urfave/cli/v3", "Flag").Values(
			jen.Op("&").Qual("github.com/urfave/cli/v3", "StringFlag").Values(jen.Dict{
				jen.Id("Name"):  jen.Lit("remote"),
				jen.Id("Usage"): jen.Lit("Remote gRPC server address (host:port). If set, uses gRPC client instead of direct call"),
			}),
			jen.Op("&").Qual("github.com/urfave/cli/v3", "StringFlag").Values(jen.Dict{
				jen.Id("Name"):  jen.Lit("format"),
				jen.Id("Value"): jen.Id("defaultFormat"),
				jen.Id("Usage"): jen.Lit("Output format (use --format to see available formats)"),
			}),
			jen.Op("&").Qual("github.com/urfave/cli/v3", "StringFlag").Values(jen.Dict{
				jen.Id("Name"):  jen.Lit("output"),
				jen.Id("Value"): jen.Lit("-"),
				jen.Id("Usage"): jen.Lit("Output file (- for stdout)"),
			}),
		),
		jen.Line(),
	)

	// Add request field flags
	for _, field := range method.Input.Fields {
		flagCode := generateFlag(field)
		if flagCode != nil {
			statements = append(statements,
				jen.Id("flags_"+cmdName).Op("=").Append(jen.Id("flags_"+cmdName), flagCode),
			)
		}
	}

	// Add config field flags if service has config
	statements = append(statements, generateConfigFlags(file, configMessageType, cmdName)...)

	// Add format-specific flags from registered formats
	statements = append(statements,
		jen.Line(),
		jen.Comment("Add format-specific flags from registered formats"),
		jen.For(
			jen.List(jen.Id("_"), jen.Id("outputFmt")).Op(":=").Range().Id("options").Dot("OutputFormats").Call(),
		).Block(
			jen.Comment("Check if format implements FlagConfiguredOutputFormat"),
			jen.If(
				jen.List(jen.Id("flagConfigured"), jen.Id("ok")).Op(":=").Id("outputFmt").Assert(
					jen.Qual("github.com/drewfead/proto-cli", "FlagConfiguredOutputFormat"),
				),
				jen.Id("ok"),
			).Block(
				jen.Id("flags_"+cmdName).Op("=").Append(
					jen.Id("flags_"+cmdName),
					jen.Id("flagConfigured").Dot("Flags").Call().Op("..."),
				),
			),
		),
		jen.Line(),
	)

	// Generate the command with lifecycle hooks
	statements = append(statements,
		jen.Id("commands").Op("=").Append(
			jen.Id("commands"),
			jen.Op("&").Qual("github.com/urfave/cli/v3", "Command").Values(jen.Dict{
				jen.Id("Name"):  jen.Lit(cmdName),
				jen.Id("Usage"): jen.Lit("Call " + method.GoName + " RPC"),
				jen.Id("Flags"): jen.Id("flags_" + cmdName),
				jen.Id("Action"): jen.Func().Params(
					jen.Id("cmdCtx").Qual("context", "Context"),
					jen.Id("cmd").Op("*").Qual("github.com/urfave/cli/v3", "Command"),
				).Error().Block(
					generateActionBodyWithHooks(service, method, configMessageType)...,
				),
			}),
		),
		jen.Line(),
	)

	return statements
}

func generateFlag(field *protogen.Field) jen.Code {
	flagName := strings.ToLower(field.GoName)

	switch field.Desc.Kind() {
	case protoreflect.Int64Kind:
		return jen.Op("&").Qual("github.com/urfave/cli/v3", "IntFlag").Values(jen.Dict{
			jen.Id("Name"):  jen.Lit(flagName),
			jen.Id("Usage"): jen.Lit(field.GoName),
		})
	case protoreflect.StringKind:
		return jen.Op("&").Qual("github.com/urfave/cli/v3", "StringFlag").Values(jen.Dict{
			jen.Id("Name"):  jen.Lit(flagName),
			jen.Id("Usage"): jen.Lit(field.GoName),
		})
	case protoreflect.BoolKind:
		return jen.Op("&").Qual("github.com/urfave/cli/v3", "BoolFlag").Values(jen.Dict{
			jen.Id("Name"):  jen.Lit(flagName),
			jen.Id("Usage"): jen.Lit(field.GoName),
		})
	default:
		return nil
	}
}

// generateConfigFlags generates CLI flags for config message fields
func generateConfigFlags(file *protogen.File, configMessageType string, cmdName string) []jen.Code {
	var statements []jen.Code

	if configMessageType == "" {
		return statements
	}

	// Find the config message in the file's messages
	var configMessage *protogen.Message
	for _, msg := range file.Messages {
		if msg.GoIdent.GoName == configMessageType {
			configMessage = msg
			break
		}
	}

	if configMessage == nil {
		return statements
	}

	statements = append(statements,
		jen.Line(),
		jen.Comment("Add config field flags for single-command mode"),
	)

	// Generate flags for each config field
	for _, field := range configMessage.Fields {
		// Get the cli.flag annotation if present
		flagOpts := getFieldFlagOptions(field)
		if flagOpts == nil {
			// No flag annotation, skip this field
			continue
		}

		flagName := flagOpts.Name
		if flagName == "" {
			flagName = strings.ToLower(field.GoName)
		}

		usage := flagOpts.Usage
		if usage == "" {
			usage = field.GoName
		}

		// Generate flag based on field type
		var flagCode jen.Code
		switch field.Desc.Kind() {
		case protoreflect.Int64Kind, protoreflect.Int32Kind:
			flagCode = jen.Op("&").Qual("github.com/urfave/cli/v3", "IntFlag").Values(jen.Dict{
				jen.Id("Name"):  jen.Lit(flagName),
				jen.Id("Usage"): jen.Lit(usage),
			})
		case protoreflect.StringKind:
			flagCode = jen.Op("&").Qual("github.com/urfave/cli/v3", "StringFlag").Values(jen.Dict{
				jen.Id("Name"):  jen.Lit(flagName),
				jen.Id("Usage"): jen.Lit(usage),
			})
		case protoreflect.BoolKind:
			flagCode = jen.Op("&").Qual("github.com/urfave/cli/v3", "BoolFlag").Values(jen.Dict{
				jen.Id("Name"):  jen.Lit(flagName),
				jen.Id("Usage"): jen.Lit(usage),
			})
		default:
			continue
		}

		if flagCode != nil {
			statements = append(statements,
				jen.Id("flags_"+cmdName).Op("=").Append(jen.Id("flags_"+cmdName), flagCode),
			)
		}
	}

	return statements
}

// getFieldFlagOptions extracts the (cli.flag) annotation from a field
func getFieldFlagOptions(field *protogen.Field) *clipb.FlagOptions {
	opts := field.Desc.Options()
	if opts == nil {
		return nil
	}

	if !proto.HasExtension(opts, clipb.E_Flag) {
		return nil
	}

	ext := proto.GetExtension(opts, clipb.E_Flag)
	if ext == nil {
		return nil
	}

	return ext.(*clipb.FlagOptions)
}

// generateRequestFieldAssignments generates code to assign flag values to request fields
func generateRequestFieldAssignments(method *protogen.Method) []jen.Code {
	var statements []jen.Code

	for _, field := range method.Input.Fields {
		flagName := strings.ToLower(field.GoName)

		switch field.Desc.Kind() {
		case protoreflect.Int64Kind:
			statements = append(statements,
				jen.Id("req").Dot(field.GoName).Op("=").Int64().Call(
					jen.Id("cmd").Dot("Int").Call(jen.Lit(flagName)),
				),
			)
		case protoreflect.StringKind:
			statements = append(statements,
				jen.Id("req").Dot(field.GoName).Op("=").Id("cmd").Dot("String").Call(jen.Lit(flagName)),
			)
		case protoreflect.BoolKind:
			statements = append(statements,
				jen.Id("req").Dot(field.GoName).Op("=").Id("cmd").Dot("Bool").Call(jen.Lit(flagName)),
			)
		}
	}

	return statements
}

func generateActionBodyWithHooks(service *protogen.Service, method *protogen.Method, configMessageType string) []jen.Code {
	var statements []jen.Code

	// Call before hook if set
	statements = append(statements,
		jen.If(jen.Id("options").Dot("BeforeCommand").Call().Op("!=").Nil()).Block(
			jen.If(
				jen.Err().Op(":=").Id("options").Dot("BeforeCommand").Call().Call(
					jen.Id("cmdCtx"),
					jen.Id("cmd"),
				),
				jen.Err().Op("!=").Nil(),
			).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(
					jen.Lit("before hook failed: %w"),
					jen.Err(),
				)),
			),
		),
		jen.Line(),
	)

	// Defer after hook
	statements = append(statements,
		jen.Defer().Func().Params().Block(
			jen.If(jen.Id("options").Dot("AfterCommand").Call().Op("!=").Nil()).Block(
				jen.If(
					jen.Err().Op(":=").Id("options").Dot("AfterCommand").Call().Call(
						jen.Id("cmdCtx"),
						jen.Id("cmd"),
					),
					jen.Err().Op("!=").Nil(),
				).Block(
					jen.Qual("fmt", "Fprintf").Call(
						jen.Qual("os", "Stderr"),
						jen.Lit("after hook failed: %v\n"),
						jen.Err(),
					),
				),
			),
		).Call(),
		jen.Line(),
	)

	// Build request - check for custom deserializer first
	requestTypeName := method.Input.GoIdent.GoName

	// First, check for custom deserializer
	statements = append(statements,
		jen.Comment("Build request message"),
		jen.Var().Id("req").Op("*").Id(requestTypeName),
		jen.Line(),
	)

	// Generate the if-else block for custom deserializer vs auto-generated
	deserializerCheck := []jen.Code{
		jen.Comment("Check for custom flag deserializer"),
		jen.List(jen.Id("deserializer"), jen.Id("hasDeserializer")).Op(":=").Id("options").Dot("FlagDeserializer").Call(
			jen.Lit(requestTypeName),
		),
		jen.If(jen.Id("hasDeserializer")).Block(
			jen.Comment("Use custom deserializer"),
			jen.List(jen.Id("msg"), jen.Err()).Op(":=").Id("deserializer").Call(
				jen.Id("cmdCtx"),
				jen.Id("cmd"),
			),
			jen.If(jen.Err().Op("!=").Nil()).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(
					jen.Lit("custom deserializer failed: %w"),
					jen.Err(),
				)),
			),
			jen.Var().Id("ok").Bool(),
			jen.List(jen.Id("req"), jen.Id("ok")).Op("=").Id("msg").Assert(jen.Op("*").Id(requestTypeName)),
			jen.If(jen.Op("!").Id("ok")).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(
					jen.Lit("custom deserializer returned wrong type: expected *%s, got %T"),
					jen.Lit(requestTypeName),
					jen.Id("msg"),
				)),
			),
		).Else().Block(
			append([]jen.Code{
				jen.Comment("Use auto-generated flag parsing"),
				jen.Id("req").Op("=").Op("&").Id(requestTypeName).Values(),
			}, generateRequestFieldAssignments(method)...)...,
		),
		jen.Line(),
	}

	statements = append(statements, deserializerCheck...)

	// Check if remote flag is set and call either remote or direct
	clientType := "New" + service.GoName + "Client"
	statements = append(statements,
		jen.Comment("Check if using remote gRPC call or direct implementation call"),
		jen.Id("remoteAddr").Op(":=").Id("cmd").Dot("String").Call(jen.Lit("remote")),
		jen.Var().Id("resp").Op("*").Id(method.Output.GoIdent.GoName),
		jen.Var().Err().Error(),
		jen.Line(),
		jen.If(jen.Id("remoteAddr").Op("!=").Lit("")).Block(
			jen.Comment("Remote gRPC call"),
			jen.List(jen.Id("conn"), jen.Id("connErr")).Op(":=").Qual("google.golang.org/grpc", "NewClient").Call(
				jen.Id("remoteAddr"),
				jen.Qual("google.golang.org/grpc", "WithTransportCredentials").Call(
					jen.Qual("google.golang.org/grpc/credentials/insecure", "NewCredentials").Call(),
				),
			),
			jen.If(jen.Id("connErr").Op("!=").Nil()).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(
					jen.Lit("failed to connect to remote %s: %w"),
					jen.Id("remoteAddr"),
					jen.Id("connErr"),
				)),
			),
			jen.Defer().Id("conn").Dot("Close").Call(),
			jen.Line(),
			jen.Id("client").Op(":=").Id(clientType).Call(jen.Id("conn")),
			jen.List(jen.Id("resp"), jen.Err()).Op("=").Id("client").Dot(method.GoName).Call(
				jen.Id("cmdCtx"),
				jen.Id("req"),
			),
			jen.If(jen.Err().Op("!=").Nil()).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("remote call failed: %w"), jen.Err())),
			),
		).Else().Block(
			generateLocalCallLogic(service, method, configMessageType)...,
		),
		jen.Line(),
	)

	// Handle output formatting
	statements = append(statements,
		jen.Comment("Open output writer"),
		jen.List(jen.Id("outputWriter"), jen.Err()).Op(":=").Id("getOutputWriter").Call(
			jen.Id("cmd").Dot("String").Call(jen.Lit("output")),
		),
		jen.If(jen.Err().Op("!=").Nil()).Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("failed to open output: %w"), jen.Err())),
		),
		jen.If(jen.Id("closer").Op(",").Id("ok").Op(":=").Id("outputWriter").Assert(jen.Qual("io", "Closer")), jen.Id("ok")).Block(
			jen.Defer().Id("closer").Dot("Close").Call(),
		),
		jen.Line(),
	)

	statements = append(statements,
		jen.Comment("Find and use the appropriate output format"),
		jen.Id("formatName").Op(":=").Id("cmd").Dot("String").Call(jen.Lit("format")),
		jen.Line(),
		jen.Comment("Try registered formats"),
		jen.For(
			jen.List(jen.Id("_"), jen.Id("outputFmt")).Op(":=").Range().Id("options").Dot("OutputFormats").Call(),
		).Block(
			jen.If(jen.Id("outputFmt").Dot("Name").Call().Op("==").Id("formatName")).Block(
				jen.If(
					jen.Err().Op(":=").Id("outputFmt").Dot("Format").Call(
						jen.Id("cmdCtx"),
						jen.Id("cmd"),
						jen.Id("outputWriter"),
						jen.Id("resp"),
					),
					jen.Err().Op("!=").Nil(),
				).Block(
					jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("format failed: %w"), jen.Err())),
				),
				jen.Return(jen.Nil()),
			),
		),
		jen.Line(),
		jen.Comment("Format not found - build list of available formats"),
		jen.Var().Id("availableFormats").Index().String(),
		jen.For(
			jen.List(jen.Id("_"), jen.Id("f")).Op(":=").Range().Id("options").Dot("OutputFormats").Call(),
		).Block(
			jen.Id("availableFormats").Op("=").Append(
				jen.Id("availableFormats"),
				jen.Id("f").Dot("Name").Call(),
			),
		),
		jen.If(jen.Len(jen.Id("availableFormats")).Op("==").Lit(0)).Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(
				jen.Lit("no output formats registered (use WithOutputFormats to register formats)"),
			)),
		),
		jen.Return(jen.Qual("fmt", "Errorf").Call(
			jen.Lit("unknown format %q (available: %v)"),
			jen.Id("formatName"),
			jen.Id("availableFormats"),
		)),
	)

	return statements
}
// generateLocalCallLogic generates the logic for calling the service implementation locally
func generateLocalCallLogic(service *protogen.Service, method *protogen.Method, configMessageType string) []jen.Code {
	var statements []jen.Code

	if configMessageType != "" {
		// Service has config - need to load it and call factory
		statements = append(statements,
			jen.Comment("Load config and create service implementation"),
			jen.Comment("Get config paths and env prefix from root command"),
			jen.Id("rootCmd").Op(":=").Id("cmd").Dot("Root").Call(),
			jen.Id("configPaths").Op(":=").Id("rootCmd").Dot("StringSlice").Call(jen.Lit("config")),
			jen.Id("envPrefix").Op(":=").Id("rootCmd").Dot("String").Call(jen.Lit("env-prefix")),
			jen.Line(),
			jen.Comment("Create config loader (single-command mode = uses files + env + flags)"),
			jen.Id("loader").Op(":=").Qual("github.com/drewfead/proto-cli", "NewConfigLoader").Call(
				jen.Qual("github.com/drewfead/proto-cli", "SingleCommandMode"),
				jen.Qual("github.com/drewfead/proto-cli", "FileConfig").Call(jen.Id("configPaths").Op("...")),
				jen.Qual("github.com/drewfead/proto-cli", "EnvPrefix").Call(jen.Id("envPrefix")),
			),
			jen.Line(),
			jen.Comment("Create config instance and load configuration"),
			jen.Id("config").Op(":=").Op("&").Id(configMessageType).Values(),
			jen.If(
				jen.Err().Op(":=").Id("loader").Dot("LoadServiceConfig").Call(
					jen.Id("cmd"),
					jen.Lit(strings.ToLower(service.GoName)),
					jen.Id("config"),
				),
				jen.Err().Op("!=").Nil(),
			).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("failed to load config: %w"), jen.Err())),
			),
			jen.Line(),
			jen.Comment("Call factory to create service implementation"),
			jen.List(jen.Id("svcImpl"), jen.Err()).Op(":=").Qual("github.com/drewfead/proto-cli", "CallFactory").Call(
				jen.Id("implOrFactory"),
				jen.Id("config"),
			),
			jen.If(jen.Err().Op("!=").Nil()).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("failed to create service: %w"), jen.Err())),
			),
			jen.Line(),
			jen.Comment("Call the RPC method"),
			jen.List(jen.Id("resp"), jen.Err()).Op("=").Id("svcImpl").Assert(jen.Id(service.GoName+"Server")).Dot(method.GoName).Call(
				jen.Id("cmdCtx"),
				jen.Id("req"),
			),
			jen.If(jen.Err().Op("!=").Nil()).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("method failed: %w"), jen.Err())),
			),
		)
	} else {
		// No config - direct implementation call
		statements = append(statements,
			jen.Comment("Direct implementation call (no config)"),
			jen.Id("svcImpl").Op(":=").Id("implOrFactory").Assert(jen.Id(service.GoName+"Server")),
			jen.List(jen.Id("resp"), jen.Err()).Op("=").Id("svcImpl").Dot(method.GoName).Call(
				jen.Id("cmdCtx"),
				jen.Id("req"),
			),
			jen.If(jen.Err().Op("!=").Nil()).Block(
				jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("method failed: %w"), jen.Err())),
			),
		)
	}

	return statements
}

func generateDaemonizeCommand(service *protogen.Service) []jen.Code {
	var statements []jen.Code

	statements = append(statements,
		jen.Comment("Generate daemonize command"),
		jen.Id("commands").Op("=").Append(
			jen.Id("commands"),
			jen.Op("&").Qual("github.com/urfave/cli/v3", "Command").Values(jen.Dict{
				jen.Id("Name"):  jen.Lit("daemonize"),
				jen.Id("Usage"): jen.Lit("Start a gRPC server with " + service.GoName),
				jen.Id("Flags"): jen.Index().Qual("github.com/urfave/cli/v3", "Flag").Values(
					jen.Op("&").Qual("github.com/urfave/cli/v3", "StringFlag").Values(jen.Dict{
						jen.Id("Name"):  jen.Lit("host"),
						jen.Id("Value"): jen.Lit("0.0.0.0"),
						jen.Id("Usage"): jen.Lit("Host to bind the gRPC server to"),
					}),
					jen.Op("&").Qual("github.com/urfave/cli/v3", "IntFlag").Values(jen.Dict{
						jen.Id("Name"):  jen.Lit("port"),
						jen.Id("Value"): jen.Lit(50051),
						jen.Id("Usage"): jen.Lit("Port to bind the gRPC server to"),
					}),
				),
				jen.Id("Action"): jen.Func().Params(
					jen.Id("cmdCtx").Qual("context", "Context"),
					jen.Id("cmd").Op("*").Qual("github.com/urfave/cli/v3", "Command"),
				).Error().Block(
					generateDaemonizeAction(service)...,
				),
			}),
		),
		jen.Line(),
	)

	return statements
}

func generateDaemonizeAction(service *protogen.Service) []jen.Code {
	var statements []jen.Code

	// Build address
	statements = append(statements,
		jen.Id("host").Op(":=").Id("cmd").Dot("String").Call(jen.Lit("host")),
		jen.Id("port").Op(":=").Id("cmd").Dot("Int").Call(jen.Lit("port")),
		jen.Id("address").Op(":=").Qual("fmt", "Sprintf").Call(
			jen.Lit("%s:%d"),
			jen.Id("host"),
			jen.Id("port"),
		),
		jen.Line(),
	)

	// Create listener
	statements = append(statements,
		jen.Comment("Create TCP listener"),
		jen.List(jen.Id("lis"), jen.Err()).Op(":=").Qual("net", "Listen").Call(
			jen.Lit("tcp"),
			jen.Id("address"),
		),
		jen.If(jen.Err().Op("!=").Nil()).Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(
				jen.Lit("failed to listen on %s: %w"),
				jen.Id("address"),
				jen.Err(),
			)),
		),
		jen.Line(),
	)

	// Create gRPC server
	statements = append(statements,
		jen.Comment("Create gRPC server"),
		jen.Id("grpcServer").Op(":=").Qual("google.golang.org/grpc", "NewServer").Call(),
		jen.Line(),
	)

	// Register service
	registerFunc := "Register" + service.GoName + "Server"
	statements = append(statements,
		jen.Comment("Register service implementation"),
		jen.Id(registerFunc).Call(
			jen.Id("grpcServer"),
			jen.Id("impl"),
		),
		jen.Line(),
	)

	// Start server
	statements = append(statements,
		jen.Qual("fmt", "Fprintf").Call(
			jen.Qual("os", "Stdout"),
			jen.Lit("Starting gRPC server on %s\n"),
			jen.Id("address"),
		),
		jen.Line(),
		jen.Comment("Start serving (blocking)"),
		jen.If(jen.Err().Op(":=").Id("grpcServer").Dot("Serve").Call(jen.Id("lis")), jen.Err().Op("!=").Nil()).Block(
			jen.Return(jen.Qual("fmt", "Errorf").Call(
				jen.Lit("failed to serve: %w"),
				jen.Err(),
			)),
		),
		jen.Line(),
		jen.Return(jen.Nil()),
	)

	return statements
}
